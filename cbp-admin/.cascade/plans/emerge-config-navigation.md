# Emerge Config Navigation Design

## Overview
Design for integrating configuration sections into the existing navigation system while maintaining type safety and code generation capabilities.

## Current System
- Uses `NavigationItem` interface for menu items
- Supports nested navigation with children
- Handles permissions and badges
- Uses React Router for routing

## Navigation Structure

### 1. Route Configuration
```typescript
// src/routes/emerge-config.routes.ts
import { lazy } from 'react';
import { RouteConfig } from '../types/route.types';

export const emergeConfigRoutes: RouteConfig[] = [
    {
        path: '/admin/emerge-config',
        element: lazy(() => import('../components/emerge-config/EmergeConfigLanding')),
        children: [
            {
                path: ':groupId/:sectionId',
                element: lazy(() => import('../components/emerge-config/ConfigSectionWrapper'))
            }
        ]
    }
];
```

### 2. Section Registry
```typescript
// src/components/emerge-config/registry/ConfigSectionRegistry.ts
export class ConfigSectionRegistry {
    private static sections = new Map<string, typeof EmergeConfigSection>();
    private static navigationItems: NavigationItem[] = [];

    // Auto-registration support
    static register(key: string, section: typeof EmergeConfigSection): void {
        this.sections.set(key, section);
        this.updateNavigation();
    }

    // Lazy loading support
    static async loadSection(groupId: string, sectionId: string): Promise<typeof EmergeConfigSection> {
        const key = `${groupId}.${sectionId}`;
        if (!this.sections.has(key)) {
            const module = await import(`../sections/${groupId}/${sectionId}`);
            // Registration happens automatically via static initializer
            return module.default;
        }
        return this.sections.get(key)!;
    }

    private static updateNavigation(): void {
        this.navigationItems = Array.from(this.sections.values())
            .map(section => section.getNavigationItem())
            .sort((a, b) => a.title.localeCompare(b.title));
    }

    static getSection(groupId: string, sectionId: string): typeof EmergeConfigSection | undefined {
        return Array.from(this.sections.values())
            .find(section => 
                section.metadata.groupId === groupId && 
                section.metadata.sectionId === sectionId
            );
    }

    static getNavigationItems(): NavigationItem[] {
        return this.navigationItems;
    }
}
```

For details on the complete registration flow and component integration, see `component-registration-flow.md`.

### 3. Section Wrapper
```typescript
// src/components/emerge-config/ConfigSectionWrapper.tsx
export const ConfigSectionWrapper: React.FC = () => {
    const { groupId, sectionId } = useParams();
    const Section = ConfigSectionRegistry.getSection(groupId, sectionId);
    
    if (!Section) {
        return <NotFound />;
    }
    
    return <Section />;
};
```

### 4. Generated Navigation
```typescript
// Generated by legacy-analyzer
export class AccountCategoriesSection extends EmergeConfigSection<AccountConfig> {
    static metadata: ConfigMetadata = {
        key: 'Account.Categories',
        groupId: 'accounts',  // For URL
        sectionId: 'categories',  // For URL
        label: 'Account Categories',
        icon: AccountBalanceIcon,
        category: 'Account Management'
    };
    
    static {
        // Auto-register with navigation
        ConfigSectionRegistry.register('accounts.categories', AccountCategoriesSection);
    }
}
```

## URL Structure
- Base: `/admin/emerge-config`
- Landing: `/admin/emerge-config`
- Section: `/admin/emerge-config/:groupId/:sectionId`
- Example: `/admin/emerge-config/accounts/categories`

## Integration Points

### 1. Navigation Context
```typescript
// src/context/NavigationContext.tsx
export interface ConfigNavigationState {
    activeGroup: string | null;
    activeSection: string | null;
}

export const ConfigNavigationProvider: React.FC = ({ children }) => {
    const [state, setState] = useState<ConfigNavigationState>({
        activeGroup: null,
        activeSection: null
    });
    
    // Navigation logic
};
```

### 2. Menu Integration
```typescript
// src/components/navigation/ConfigNavigation.tsx
export const ConfigNavigation: React.FC = () => {
    const items = ConfigSectionRegistry.getNavigationItems();
    
    return (
        <NavigationContent 
            items={items}
            basePath="/admin/emerge-config"
        />
    );
};
```

## Code Generation

### 1. Navigation Metadata
Generated in section files:
```typescript
// Generated navigation metadata
static navigationMetadata = {
    groupId: 'accounts',
    sectionId: 'categories',
    menuPath: ['Account Management', 'Categories'],
    icon: AccountBalanceIcon,
    permissions: ['config.account.read']
};
```

### 2. Route Registration
Auto-generated route configuration:
```typescript
// Generated in routes/index.ts
export const generatedRoutes = [
    {
        path: '/admin/emerge-config/accounts/categories',
        element: lazy(() => import('../sections/accounts/AccountCategoriesSection')),
        navigationMetadata: AccountCategoriesSection.navigationMetadata
    }
];
```

## Implementation Steps

1. **Base Infrastructure**
   - Create ConfigSectionWrapper
   - Implement ConfigSectionRegistry
   - Add navigation context

2. **Code Generation**
   - Add navigation metadata generation
   - Generate route configurations
   - Add auto-registration

3. **Integration**
   - Hook into existing navigation
   - Add permission handling
   - Implement breadcrumbs
   - Add loading states

4. **Testing**
   - Test route generation
   - Verify navigation state
   - Test section loading
   - Validate permissions

## Validation Tests

### 1. Registry Tests
```typescript
// Test at implementation of registry
describe('ConfigSectionRegistry', () => {
    // Registration
    it('should register sections', () => {
        const TestSection = createTestSection();
        ConfigSectionRegistry.register('test', TestSection);
        expect(ConfigSectionRegistry.getSection('test')).toBe(TestSection);
    });

    // Navigation Items
    it('should generate navigation items', () => {
        const items = ConfigSectionRegistry.getNavigationItems();
        expect(items[0]).toMatchObject({
            id: 'test',
            title: 'Test Section',
            path: '/admin/emerge-config/test'
        });
    });

    // Permissions
    it('should respect permissions', () => {
        mockPermissions.deny('config.test');
        const items = ConfigSectionRegistry.getNavigationItems();
        expect(items).not.toContainEqual(
            expect.objectContaining({ id: 'test' })
        );
    });
});
```

### 2. Route Tests
```typescript
// Test at implementation of router
describe('ConfigRouter', () => {
    // Route Loading
    it('should load correct section', async () => {
        const { container } = render(
            <MemoryRouter initialEntries={['/admin/emerge-config/test']}>
                <ConfigRouter />
            </MemoryRouter>
        );
        await waitFor(() => {
            expect(container.querySelector('TestSection')).toBeInTheDocument();
        });
    });

    // Not Found
    it('should handle invalid routes', () => {
        const { container } = render(
            <MemoryRouter initialEntries={['/admin/emerge-config/invalid']}>
                <ConfigRouter />
            </MemoryRouter>
        );
        expect(container.querySelector('NotFound')).toBeInTheDocument();
    });

    // Loading State
    it('should show loading state', () => {
        const { container } = render(
            <MemoryRouter initialEntries={['/admin/emerge-config/test']}>
                <ConfigRouter />
            </MemoryRouter>
        );
        expect(container.querySelector('LoadingIndicator')).toBeInTheDocument();
    });
});
```

### 3. Navigation State Tests
```typescript
// Test at implementation of navigation context
describe('ConfigNavigationProvider', () => {
    // State Updates
    it('should update active section', () => {
        const { result } = renderHook(() => useNavigation());
        act(() => {
            result.current.setActiveSection('test');
        });
        expect(result.current.state.activeSection).toBe('test');
    });

    // URL Sync
    it('should sync with URL', () => {
        const { result } = renderHook(() => useNavigation(), {
            wrapper: MemoryRouter
        });
        act(() => {
            result.current.navigate('/admin/emerge-config/test');
        });
        expect(result.current.state.activeSection).toBe('test');
    });

    // Persistence
    it('should persist state', () => {
        const { result, rerender } = renderHook(() => useNavigation());
        act(() => {
            result.current.setActiveSection('test');
        });
        rerender();
        expect(result.current.state.activeSection).toBe('test');
    });
});
```

### 4. Integration Tests
```typescript
// Test after connecting components
describe('Navigation Integration', () => {
    // Menu + Router
    it('should navigate on menu click', async () => {
        const { container } = render(<ConfigNavigation />);
        fireEvent.click(screen.getByText('Test Section'));
        await waitFor(() => {
            expect(container.querySelector('TestSection')).toBeInTheDocument();
        });
    });

    // State + URL
    it('should sync state and URL', () => {
        const { result } = renderHook(() => useNavigation());
        act(() => {
            result.current.navigate('/admin/emerge-config/test');
        });
        expect(window.location.pathname).toBe('/admin/emerge-config/test');
    });
});
```

### 5. Error Boundary Tests
```typescript
// Test at implementation of error boundaries
describe('NavigationErrorBoundary', () => {
    // Loading Errors
    it('should handle section load errors', () => {
        const TestSection = createErrorSection();
        ConfigSectionRegistry.register('error', TestSection);
        
        const { container } = render(
            <MemoryRouter initialEntries={['/admin/emerge-config/error']}>
                <ConfigRouter />
            </MemoryRouter>
        );
        expect(container.querySelector('ErrorDisplay')).toBeInTheDocument();
    });

    // Recovery
    it('should allow navigation after error', async () => {
        const { container } = render(<ConfigNavigation />);
        // Navigate to error section
        fireEvent.click(screen.getByText('Error Section'));
        // Navigate away
        fireEvent.click(screen.getByText('Test Section'));
        await waitFor(() => {
            expect(container.querySelector('TestSection')).toBeInTheDocument();
        });
    });
});
```

Each test suite should be implemented:
1. During initial setup of each component
2. When adding new navigation features
3. After modifying routing logic
4. During integration phases
