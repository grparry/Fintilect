diff --git a/cbp-admin/.cascade/plans/emerge-config-navigation.md b/cbp-admin/.cascade/plans/emerge-config-navigation.md
index 62e8881..a9db163 100644
--- a/cbp-admin/.cascade/plans/emerge-config-navigation.md
+++ b/cbp-admin/.cascade/plans/emerge-config-navigation.md
@@ -8,65 +8,73 @@ Design for integrating configuration sections into the existing navigation syste
 - Supports nested navigation with children
 - Handles permissions and badges
 - Uses React Router for routing
+- Main landing page (`EmergeConfigLanding`)
+- Section landing pages (e.g., `CoreSettingsLanding`)
+- Material-UI based card navigation
 
 ## Navigation Structure
 
 ### 1. Route Configuration
 ```typescript
-// src/routes/emerge-config.routes.ts
-import { lazy } from 'react';
-import { RouteConfig } from '../types/route.types';
-
-export const emergeConfigRoutes: RouteConfig[] = [
+// Current route structure
+const emergeConfigRoutes: RouteConfig[] = [
     {
-        path: '/admin/emerge-config',
-        element: lazy(() => import('../components/emerge-config/EmergeConfigLanding')),
+        id: 'emergeConfig-core',
+        path: 'core',
+        title: 'Core Settings',
+        element: CoreSettingsLanding,
+        icon: SettingsApplicationsIcon,
         children: [
             {
-                path: ':groupId/:sectionId',
-                element: lazy(() => import('../components/emerge-config/ConfigSectionWrapper'))
+                id: 'emergeConfig-core-general',
+                path: 'general',
+                title: 'General Settings',
+                element: ConfigPlaceholder
             }
         ]
     }
 ];
 ```
 
-### 2. Section Registry
+### 2. Component Integration
+```typescript
+// Generated component using base class
+export class CoreGeneralSettings extends EmergeConfigSection<GeneralConfig> {
+    static metadata: ConfigMetadata = {
+        key: 'Core.General',
+        label: 'General Settings',
+        category: 'Core Settings'
+    };
+
+    render() {
+        return (
+            <ConfigSection>
+                <SettingsForm
+                    value={this.getValue()}
+                    onChange={this.setValue}
+                    validation={this.getValidationRules()}
+                    layout={this.getLayout()}
+                />
+            </ConfigSection>
+        );
+    }
+}
+```
+
+### 3. Section Registry
 ```typescript
 // src/components/emerge-config/registry/ConfigSectionRegistry.ts
 export class ConfigSectionRegistry {
     private static sections = new Map<string, typeof EmergeConfigSection>();
     private static navigationItems: NavigationItem[] = [];
 
-    // Auto-registration support
     static register(key: string, section: typeof EmergeConfigSection): void {
         this.sections.set(key, section);
         this.updateNavigation();
     }
 
-    // Lazy loading support
-    static async loadSection(groupId: string, sectionId: string): Promise<typeof EmergeConfigSection> {
-        const key = `${groupId}.${sectionId}`;
-        if (!this.sections.has(key)) {
-            const module = await import(`../sections/${groupId}/${sectionId}`);
-            // Registration happens automatically via static initializer
-            return module.default;
-        }
-        return this.sections.get(key)!;
-    }
-
-    private static updateNavigation(): void {
-        this.navigationItems = Array.from(this.sections.values())
-            .map(section => section.getNavigationItem())
-            .sort((a, b) => a.title.localeCompare(b.title));
-    }
-
     static getSection(groupId: string, sectionId: string): typeof EmergeConfigSection | undefined {
-        return Array.from(this.sections.values())
-            .find(section => 
-                section.metadata.groupId === groupId && 
-                section.metadata.sectionId === sectionId
-            );
+        return this.sections.get(`${groupId}.${sectionId}`);
     }
 
     static getNavigationItems(): NavigationItem[] {
@@ -75,141 +83,95 @@ export class ConfigSectionRegistry {
 }
 ```
 
-For details on the complete registration flow and component integration, see `component-registration-flow.md`.
+## Component Organization
 
-### 3. Section Wrapper
-```typescript
-// src/components/emerge-config/ConfigSectionWrapper.tsx
-export const ConfigSectionWrapper: React.FC = () => {
-    const { groupId, sectionId } = useParams();
-    const Section = ConfigSectionRegistry.getSection(groupId, sectionId);
-    
-    if (!Section) {
-        return <NotFound />;
-    }
-    
-    return <Section />;
-};
+### 1. Directory Structure
 ```
-
-### 4. Generated Navigation
-```typescript
-// Generated by legacy-analyzer
-export class AccountCategoriesSection extends EmergeConfigSection<AccountConfig> {
-    static metadata: ConfigMetadata = {
-        key: 'Account.Categories',
-        groupId: 'accounts',  // For URL
-        sectionId: 'categories',  // For URL
-        label: 'Account Categories',
-        icon: AccountBalanceIcon,
-        category: 'Account Management'
-    };
-    
-    static {
-        // Auto-register with navigation
-        ConfigSectionRegistry.register('accounts.categories', AccountCategoriesSection);
-    }
-}
+src/components/emerge-config/
+  ├── core/
+  │   ├── CoreSettingsLanding.tsx
+  │   ├── general/               # Generated
+  │   │   ├── index.tsx
+  │   │   ├── types.ts
+  │   │   └── validation.ts
+  │   └── branding/             # Generated
+  ├── accounts/
+  └── auth-security/
 ```
 
-## URL Structure
-- Base: `/admin/emerge-config`
-- Landing: `/admin/emerge-config`
-- Section: `/admin/emerge-config/:groupId/:sectionId`
-- Example: `/admin/emerge-config/accounts/categories`
-
-## Integration Points
-
-### 1. Navigation Context
+### 2. Layout Integration
 ```typescript
-// src/context/NavigationContext.tsx
-export interface ConfigNavigationState {
-    activeGroup: string | null;
-    activeSection: string | null;
-}
-
-export const ConfigNavigationProvider: React.FC = ({ children }) => {
-    const [state, setState] = useState<ConfigNavigationState>({
-        activeGroup: null,
-        activeSection: null
-    });
-    
-    // Navigation logic
-};
+// Layout integration
+const SettingsLayout: React.FC = ({ children }) => (
+    <Box sx={{ p: 3 }}>
+        <Typography variant="h4" gutterBottom>
+            {metadata.label}
+        </Typography>
+        <Card>
+            <CardContent>
+                {children}
+            </CardContent>
+        </Card>
+    </Box>
+);
 ```
 
-### 2. Menu Integration
-```typescript
-// src/components/navigation/ConfigNavigation.tsx
-export const ConfigNavigation: React.FC = () => {
-    const items = ConfigSectionRegistry.getNavigationItems();
-    
-    return (
-        <NavigationContent 
-            items={items}
-            basePath="/admin/emerge-config"
-        />
-    );
-};
-```
-
-## Code Generation
+## Generator Integration
 
-### 1. Navigation Metadata
-Generated in section files:
+### 1. Component Generation
 ```typescript
-// Generated navigation metadata
-static navigationMetadata = {
-    groupId: 'accounts',
-    sectionId: 'categories',
-    menuPath: ['Account Management', 'Categories'],
-    icon: AccountBalanceIcon,
-    permissions: ['config.account.read']
-};
+// Generator template
+export function generateComponent(schema: SchemaDefinition): string {
+    return `
+        export class ${schema.className} extends EmergeConfigSection<${schema.typeName}> {
+            static metadata: ConfigMetadata = ${JSON.stringify(schema.metadata)};
+            
+            protected getDefaultValue(): ${schema.typeName} {
+                return ${JSON.stringify(schema.defaultValue)};
+            }
+            
+            protected getValidationRules(): ValidationRules {
+                return ${JSON.stringify(schema.validationRules)};
+            }
+
+            render() {
+                return (
+                    <ConfigSection>
+                        <SettingsForm
+                            value={this.getValue()}
+                            onChange={this.setValue}
+                            validation={this.getValidationRules()}
+                            layout={this.getLayout()}
+                        />
+                    </ConfigSection>
+                );
+            }
+        }
+    `;
+}
 ```
 
-### 2. Route Registration
-Auto-generated route configuration:
+### 2. Route Generation
 ```typescript
-// Generated in routes/index.ts
-export const generatedRoutes = [
-    {
-        path: '/admin/emerge-config/accounts/categories',
-        element: lazy(() => import('../sections/accounts/AccountCategoriesSection')),
-        navigationMetadata: AccountCategoriesSection.navigationMetadata
-    }
-];
+// Route generation template
+export function generateRouteConfig(schema: SchemaDefinition): string {
+    return `
+        {
+            id: '${schema.routeId}',
+            path: '${schema.path}',
+            title: '${schema.metadata.label}',
+            element: ${schema.className},
+            icon: ${schema.icon},
+            parent: '${schema.parentRoute}'
+        }
+    `;
+}
 ```
 
-## Implementation Steps
-
-1. **Base Infrastructure**
-   - Create ConfigSectionWrapper
-   - Implement ConfigSectionRegistry
-   - Add navigation context
-
-2. **Code Generation**
-   - Add navigation metadata generation
-   - Generate route configurations
-   - Add auto-registration
-
-3. **Integration**
-   - Hook into existing navigation
-   - Add permission handling
-   - Implement breadcrumbs
-   - Add loading states
-
-4. **Testing**
-   - Test route generation
-   - Verify navigation state
-   - Test section loading
-   - Validate permissions
-
-## Validation Tests
+## Testing Strategy
 
 ### 1. Registry Tests
 ```typescript
-// Test at implementation of registry
 describe('ConfigSectionRegistry', () => {
     // Registration
     it('should register sections', () => {
@@ -239,83 +201,24 @@ describe('ConfigSectionRegistry', () => {
 });
 ```
 
-### 2. Route Tests
-```typescript
-// Test at implementation of router
-describe('ConfigRouter', () => {
-    // Route Loading
-    it('should load correct section', async () => {
-        const { container } = render(
-            <MemoryRouter initialEntries={['/admin/emerge-config/test']}>
-                <ConfigRouter />
-            </MemoryRouter>
-        );
-        await waitFor(() => {
-            expect(container.querySelector('TestSection')).toBeInTheDocument();
-        });
-    });
-
-    // Not Found
-    it('should handle invalid routes', () => {
-        const { container } = render(
-            <MemoryRouter initialEntries={['/admin/emerge-config/invalid']}>
-                <ConfigRouter />
-            </MemoryRouter>
-        );
-        expect(container.querySelector('NotFound')).toBeInTheDocument();
-    });
-
-    // Loading State
-    it('should show loading state', () => {
-        const { container } = render(
-            <MemoryRouter initialEntries={['/admin/emerge-config/test']}>
-                <ConfigRouter />
-            </MemoryRouter>
-        );
-        expect(container.querySelector('LoadingIndicator')).toBeInTheDocument();
-    });
-});
-```
-
-### 3. Navigation State Tests
+### 2. Component Tests
 ```typescript
-// Test at implementation of navigation context
-describe('ConfigNavigationProvider', () => {
-    // State Updates
-    it('should update active section', () => {
-        const { result } = renderHook(() => useNavigation());
-        act(() => {
-            result.current.setActiveSection('test');
-        });
-        expect(result.current.state.activeSection).toBe('test');
+describe('Generated Component', () => {
+    it('should integrate with existing layout', () => {
+        render(<CoreGeneralSettings />);
+        expect(screen.getByRole('heading')).toHaveTextContent('General Settings');
     });
 
-    // URL Sync
-    it('should sync with URL', () => {
-        const { result } = renderHook(() => useNavigation(), {
-            wrapper: MemoryRouter
-        });
-        act(() => {
-            result.current.navigate('/admin/emerge-config/test');
-        });
-        expect(result.current.state.activeSection).toBe('test');
-    });
-
-    // Persistence
-    it('should persist state', () => {
-        const { result, rerender } = renderHook(() => useNavigation());
-        act(() => {
-            result.current.setActiveSection('test');
-        });
-        rerender();
-        expect(result.current.state.activeSection).toBe('test');
+    it('should handle validation', () => {
+        const { getByRole } = render(<CoreGeneralSettings />);
+        fireEvent.change(getByRole('textbox'), { target: { value: 'invalid' } });
+        expect(screen.getByText('Validation Error')).toBeInTheDocument();
     });
 });
 ```
 
-### 4. Integration Tests
+### 3. Navigation Tests
 ```typescript
-// Test after connecting components
 describe('Navigation Integration', () => {
     // Menu + Router
     it('should navigate on menu click', async () => {
@@ -337,39 +240,34 @@ describe('Navigation Integration', () => {
 });
 ```
 
-### 5. Error Boundary Tests
-```typescript
-// Test at implementation of error boundaries
-describe('NavigationErrorBoundary', () => {
-    // Loading Errors
-    it('should handle section load errors', () => {
-        const TestSection = createErrorSection();
-        ConfigSectionRegistry.register('error', TestSection);
-        
-        const { container } = render(
-            <MemoryRouter initialEntries={['/admin/emerge-config/error']}>
-                <ConfigRouter />
-            </MemoryRouter>
-        );
-        expect(container.querySelector('ErrorDisplay')).toBeInTheDocument();
-    });
-
-    // Recovery
-    it('should allow navigation after error', async () => {
-        const { container } = render(<ConfigNavigation />);
-        // Navigate to error section
-        fireEvent.click(screen.getByText('Error Section'));
-        // Navigate away
-        fireEvent.click(screen.getByText('Test Section'));
-        await waitFor(() => {
-            expect(container.querySelector('TestSection')).toBeInTheDocument();
-        });
-    });
-});
-```
+## Implementation Steps
 
-Each test suite should be implemented:
-1. During initial setup of each component
-2. When adding new navigation features
-3. After modifying routing logic
-4. During integration phases
+1. **Base Structure**
+   - Create base layout components
+   - Implement form templates
+   - Add validation integration
+
+2. **Navigation Integration**
+   - Update route generation
+   - Add parent route linking
+   - Implement navigation helpers
+
+3. **Generator Updates**
+   - Add layout templates
+   - Update component generation
+   - Implement route generation
+
+4. **Testing & Validation**
+   - Implement registry tests
+   - Add component integration tests
+   - Create navigation tests
+   - Validate permissions
+   - Test error boundaries
+
+## Success Criteria
+1. Generated components integrate with existing navigation
+2. Type safety is maintained throughout
+3. All tests pass with good coverage
+4. Permissions are properly enforced
+5. Error boundaries catch and handle failures
+6. Navigation state remains consistent
diff --git a/cbp-admin/jest.config.ts b/cbp-admin/jest.config.ts
deleted file mode 100644
index 219d101..0000000
--- a/cbp-admin/jest.config.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-import type { Config } from '@jest/types';
-
-const config: Config.InitialOptions = {
-  preset: 'ts-jest',
-  testEnvironment: 'jsdom',
-  roots: ['<rootDir>/src'],
-  testMatch: ['**/__tests__/**/*.test.ts'],
-  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
-  collectCoverage: true,
-  coverageDirectory: 'coverage',
-  coveragePathIgnorePatterns: ['/node_modules/', '/__tests__/'],
-  verbose: true,
-  transform: {
-    '^.+\\.tsx?$': 'ts-jest',
-  },
-  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
-};
-
-export default config;
diff --git a/cbp-admin/src/routes/emergeConfigRoutes.ts b/cbp-admin/src/routes/emergeConfigRoutes.ts
deleted file mode 100644
index b597d1e..0000000
--- a/cbp-admin/src/routes/emergeConfigRoutes.ts
+++ /dev/null
@@ -1,491 +0,0 @@
-import { lazy } from 'react';
-import { RouteConfig } from '../types/route.types';
-import SettingsIcon from '@mui/icons-material/Settings';
-import SettingsApplicationsIcon from '@mui/icons-material/SettingsApplications';
-import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
-import CreditCardIcon from '@mui/icons-material/CreditCard';
-import SecurityIcon from '@mui/icons-material/Security';
-import RequestQuoteIcon from '@mui/icons-material/RequestQuote';
-import ManageAccountsIcon from '@mui/icons-material/ManageAccounts';
-import FolderSpecialIcon from '@mui/icons-material/FolderSpecial';
-import CampaignIcon from '@mui/icons-material/Campaign';
-import PolicyIcon from '@mui/icons-material/Policy';
-import WidgetsIcon from '@mui/icons-material/Widgets';
-import AccountBoxIcon from '@mui/icons-material/AccountBox';
-import PaymentsIcon from '@mui/icons-material/Payments';
-import LockIcon from '@mui/icons-material/Lock';
-import CurrencyExchangeIcon from '@mui/icons-material/CurrencyExchange';
-import GroupIcon from '@mui/icons-material/Group';
-import DescriptionIcon from '@mui/icons-material/Description';
-import LocalOfferIcon from '@mui/icons-material/LocalOffer';
-import GavelIcon from '@mui/icons-material/Gavel';
-import ExtensionIcon from '@mui/icons-material/Extension';
-
-// Lazy load components
-const EmergeConfigHeader = lazy(() => import('../components/emerge-config/EmergeConfigHeader'));
-const EmergeConfigLanding = lazy(() => import('../components/emerge-config/EmergeConfigLanding'));
-const CoreSettingsLanding = lazy(() => import('../components/emerge-config/core/CoreSettingsLanding'));
-const AccountsLanding = lazy(() => import('../components/emerge-config/accounts/AccountsLanding'));
-const CardsPaymentsLanding = lazy(() => import('../components/emerge-config/cards-payments/CardsPaymentsLanding'));
-const AuthSecurityLanding = lazy(() => import('../components/emerge-config/auth-security/AuthSecurityLanding'));
-const LoansCreditLanding = lazy(() => import('../components/emerge-config/loans-credit/LoansCreditLanding'));
-const UserServicesLanding = lazy(() => import('../components/emerge-config/user-services/UserServicesLanding'));
-const DocumentServicesLanding = lazy(() => import('../components/emerge-config/document-services/DocumentServicesLanding'));
-const MarketingOffersLanding = lazy(() => import('../components/emerge-config/marketing-offers/MarketingOffersLanding'));
-const ComplianceSupportLanding = lazy(() => import('../components/emerge-config/compliance-support/ComplianceSupportLanding'));
-const MiscLanding = lazy(() => import('../components/emerge-config/misc/MiscLanding'));
-const ConfigPlaceholder = lazy(() => import('../components/emerge-config/ConfigPlaceholder'));
-
-const emergeConfigRoutes: RouteConfig[] = [
-  // Root and landing routes
-  {
-    id: 'emerge-config-root',
-    path: '',
-    title: 'Emerge Config',
-    element: EmergeConfigHeader,
-    icon: SettingsIcon,
-    sectionId: 'emergeConfig',
-    hideFromSidebar: true,
-  },
-  {
-    id: 'emerge-config-landing',
-    path: '',
-    title: 'Emerge Config Overview',
-    element: EmergeConfigLanding,
-    icon: SettingsIcon,
-    sectionId: 'emergeConfig',
-    hideFromSidebar: true,
-  },
-  // Core Settings section
-  {
-    id: 'emergeConfig-core',
-    path: 'core',
-    title: 'Core Settings',
-    element: CoreSettingsLanding,
-    icon: SettingsApplicationsIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-core-general',
-        path: 'general',
-        title: 'General Settings',
-        element: ConfigPlaceholder,
-        icon: SettingsApplicationsIcon,
-        children: [
-          {
-            id: 'emergeConfig-core-general-basic',
-            path: 'basic',
-            title: 'Basic Settings',
-            element: ConfigPlaceholder,
-            icon: SettingsApplicationsIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-core-branding',
-        path: 'branding',
-        title: 'Branding',
-        element: ConfigPlaceholder,
-        icon: SettingsApplicationsIcon,
-        children: [
-          {
-            id: 'emergeConfig-core-branding-logos',
-            path: 'logos',
-            title: 'Logo Settings',
-            element: ConfigPlaceholder,
-            icon: SettingsApplicationsIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Accounts section
-  {
-    id: 'emergeConfig-accounts',
-    path: 'accounts',
-    title: 'Accounts',
-    element: AccountsLanding,
-    icon: AccountBalanceIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-accounts-types',
-        path: 'types',
-        title: 'Account Types',
-        element: ConfigPlaceholder,
-        icon: AccountBoxIcon,
-        children: [
-          {
-            id: 'emergeConfig-accounts-types-savings',
-            path: 'savings',
-            title: 'Savings Accounts',
-            element: ConfigPlaceholder,
-            icon: AccountBoxIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-accounts-features',
-        path: 'features',
-        title: 'Account Features',
-        element: ConfigPlaceholder,
-        icon: AccountBalanceIcon,
-        children: [
-          {
-            id: 'emergeConfig-accounts-features-overdraft',
-            path: 'overdraft',
-            title: 'Overdraft Settings',
-            element: ConfigPlaceholder,
-            icon: AccountBalanceIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Cards & Payments section
-  {
-    id: 'emergeConfig-cards-payments',
-    path: 'cards-payments',
-    title: 'Cards & Payments',
-    element: CardsPaymentsLanding,
-    icon: CreditCardIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-cards-settings',
-        path: 'cards',
-        title: 'Card Settings',
-        element: ConfigPlaceholder,
-        icon: CreditCardIcon,
-        children: [
-          {
-            id: 'emergeConfig-cards-settings-physical',
-            path: 'physical',
-            title: 'Physical Card Settings',
-            element: ConfigPlaceholder,
-            icon: CreditCardIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-payment-methods',
-        path: 'methods',
-        title: 'Payment Methods',
-        element: ConfigPlaceholder,
-        icon: PaymentsIcon,
-        children: [
-          {
-            id: 'emergeConfig-payment-methods-bank-transfer',
-            path: 'bank-transfer',
-            title: 'Bank Transfer Settings',
-            element: ConfigPlaceholder,
-            icon: PaymentsIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Authentication & Security section
-  {
-    id: 'emergeConfig-auth-security',
-    path: 'auth-security',
-    title: 'Authentication & Security',
-    element: AuthSecurityLanding,
-    icon: SecurityIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-auth-methods',
-        path: 'methods',
-        title: 'Authentication Methods',
-        element: ConfigPlaceholder,
-        icon: LockIcon,
-        children: [
-          {
-            id: 'emergeConfig-auth-methods-password',
-            path: 'password',
-            title: 'Password Settings',
-            element: ConfigPlaceholder,
-            icon: LockIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-security-policies',
-        path: 'policies',
-        title: 'Security Policies',
-        element: ConfigPlaceholder,
-        icon: SecurityIcon,
-        children: [
-          {
-            id: 'emergeConfig-security-policies-password-policy',
-            path: 'password-policy',
-            title: 'Password Policy Settings',
-            element: ConfigPlaceholder,
-            icon: SecurityIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Loans & Credit section
-  {
-    id: 'emergeConfig-loans-credit',
-    path: 'loans-credit',
-    title: 'Loans & Credit',
-    element: LoansCreditLanding,
-    icon: RequestQuoteIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-loan-products',
-        path: 'products',
-        title: 'Loan Products',
-        element: ConfigPlaceholder,
-        icon: CurrencyExchangeIcon,
-        children: [
-          {
-            id: 'emergeConfig-loan-products-personal-loans',
-            path: 'personal-loans',
-            title: 'Personal Loan Settings',
-            element: ConfigPlaceholder,
-            icon: CurrencyExchangeIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-credit-settings',
-        path: 'credit',
-        title: 'Credit Settings',
-        element: ConfigPlaceholder,
-        icon: RequestQuoteIcon,
-        children: [
-          {
-            id: 'emergeConfig-credit-settings-credit-score',
-            path: 'credit-score',
-            title: 'Credit Score Settings',
-            element: ConfigPlaceholder,
-            icon: RequestQuoteIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // User Services section
-  {
-    id: 'emergeConfig-user-services',
-    path: 'user-services',
-    title: 'User Services',
-    element: UserServicesLanding,
-    icon: ManageAccountsIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-user-roles',
-        path: 'roles',
-        title: 'User Roles',
-        element: ConfigPlaceholder,
-        icon: GroupIcon,
-        children: [
-          {
-            id: 'emergeConfig-user-roles-admin',
-            path: 'admin',
-            title: 'Admin Role Settings',
-            element: ConfigPlaceholder,
-            icon: GroupIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-service-settings',
-        path: 'settings',
-        title: 'Service Settings',
-        element: ConfigPlaceholder,
-        icon: ManageAccountsIcon,
-        children: [
-          {
-            id: 'emergeConfig-service-settings-notification',
-            path: 'notification',
-            title: 'Notification Settings',
-            element: ConfigPlaceholder,
-            icon: ManageAccountsIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Document Services section
-  {
-    id: 'emergeConfig-document-services',
-    path: 'document-services',
-    title: 'Document Services',
-    element: DocumentServicesLanding,
-    icon: FolderSpecialIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-document-types',
-        path: 'types',
-        title: 'Document Types',
-        element: ConfigPlaceholder,
-        icon: DescriptionIcon,
-        children: [
-          {
-            id: 'emergeConfig-document-types-identification',
-            path: 'identification',
-            title: 'Identification Document Settings',
-            element: ConfigPlaceholder,
-            icon: DescriptionIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-document-workflows',
-        path: 'workflows',
-        title: 'Document Workflows',
-        element: ConfigPlaceholder,
-        icon: FolderSpecialIcon,
-        children: [
-          {
-            id: 'emergeConfig-document-workflows-upload',
-            path: 'upload',
-            title: 'Document Upload Settings',
-            element: ConfigPlaceholder,
-            icon: FolderSpecialIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Marketing & Offers section
-  {
-    id: 'emergeConfig-marketing-offers',
-    path: 'marketing-offers',
-    title: 'Marketing & Offers',
-    element: MarketingOffersLanding,
-    icon: CampaignIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-campaign-settings',
-        path: 'campaigns',
-        title: 'Campaign Settings',
-        element: ConfigPlaceholder,
-        icon: CampaignIcon,
-        children: [
-          {
-            id: 'emergeConfig-campaign-settings-email',
-            path: 'email',
-            title: 'Email Campaign Settings',
-            element: ConfigPlaceholder,
-            icon: CampaignIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-offer-management',
-        path: 'offers',
-        title: 'Offer Management',
-        element: ConfigPlaceholder,
-        icon: LocalOfferIcon,
-        children: [
-          {
-            id: 'emergeConfig-offer-management-promotions',
-            path: 'promotions',
-            title: 'Promotion Settings',
-            element: ConfigPlaceholder,
-            icon: LocalOfferIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Compliance & Support section
-  {
-    id: 'emergeConfig-compliance-support',
-    path: 'compliance-support',
-    title: 'Compliance & Support',
-    element: ComplianceSupportLanding,
-    icon: PolicyIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-compliance-rules',
-        path: 'rules',
-        title: 'Compliance Rules',
-        element: ConfigPlaceholder,
-        icon: GavelIcon,
-        children: [
-          {
-            id: 'emergeConfig-compliance-rules-aml',
-            path: 'aml',
-            title: 'AML Settings',
-            element: ConfigPlaceholder,
-            icon: GavelIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-support-settings',
-        path: 'support',
-        title: 'Support Settings',
-        element: ConfigPlaceholder,
-        icon: PolicyIcon,
-        children: [
-          {
-            id: 'emergeConfig-support-settings-faq',
-            path: 'faq',
-            title: 'FAQ Settings',
-            element: ConfigPlaceholder,
-            icon: PolicyIcon,
-          }
-        ]
-      }
-    ]
-  },
-  // Miscellaneous section
-  {
-    id: 'emergeConfig-misc',
-    path: 'misc',
-    title: 'Miscellaneous',
-    element: MiscLanding,
-    icon: WidgetsIcon,
-    sectionId: 'emergeConfig',
-    children: [
-      {
-        id: 'emergeConfig-misc-integrations',
-        path: 'integrations',
-        title: 'Integrations',
-        element: ConfigPlaceholder,
-        icon: ExtensionIcon,
-        children: [
-          {
-            id: 'emergeConfig-misc-integrations-api',
-            path: 'api',
-            title: 'API Settings',
-            element: ConfigPlaceholder,
-            icon: ExtensionIcon,
-          }
-        ]
-      },
-      {
-        id: 'emergeConfig-misc-settings',
-        path: 'settings',
-        title: 'Other Settings',
-        element: ConfigPlaceholder,
-        icon: WidgetsIcon,
-        children: [
-          {
-            id: 'emergeConfig-misc-settings-debug',
-            path: 'debug',
-            title: 'Debug Settings',
-            element: ConfigPlaceholder,
-            icon: WidgetsIcon,
-          }
-        ]
-      }
-    ]
-  }
-];
-
-export default emergeConfigRoutes;
diff --git a/cbp-admin/src/services/interfaces/ISettingsService.ts b/cbp-admin/src/services/interfaces/ISettingsService.ts
index 7aed955..4821e08 100644
--- a/cbp-admin/src/services/interfaces/ISettingsService.ts
+++ b/cbp-admin/src/services/interfaces/ISettingsService.ts
@@ -1,5 +1,6 @@
 import { ApiSuccessResponse } from '../../types/api.types';
 import { Setting, SettingGroup } from '../../types/settings.types';
+import { ValidationResult } from '../settings/types';
 import { IBaseService } from './IBaseService';
 
 export interface ISettingsService extends IBaseService {
@@ -8,5 +9,5 @@ export interface ISettingsService extends IBaseService {
   updateSetting(key: string, value: string | number | boolean): Promise<ApiSuccessResponse<Setting>>;
   updateSettings(settings: Setting[]): Promise<ApiSuccessResponse<Setting[]>>;
   getSettingsByPrefix(prefix: string): Promise<ApiSuccessResponse<Setting[]>>;
-  validateSetting(key: string, value: any): Promise<ApiSuccessResponse<{ isValid: boolean; errors?: string[] }>>;
+  validateSetting(key: string, value: any): Promise<ApiSuccessResponse<ValidationResult>>;
 }
diff --git a/cbp-admin/src/setupTests.ts b/cbp-admin/src/setupTests.ts
index 44c7013..23cb0c8 100644
--- a/cbp-admin/src/setupTests.ts
+++ b/cbp-admin/src/setupTests.ts
@@ -1,10 +1,6 @@
 // jest-dom adds custom jest matchers for asserting on DOM nodes.
-// allows you to do things like:
-// expect(element).toHaveTextContent(/react/i)
-// learn more: https://github.com/testing-library/jest-dom
 import '@testing-library/jest-dom';
 import { configure } from '@testing-library/react';
-import 'jest-canvas-mock';
 import { TextEncoder, TextDecoder } from 'util';
 import { jest } from '@jest/globals';
 
@@ -16,54 +12,19 @@ configure({
   testIdAttribute: 'data-testid',
 });
 
-// Mock fetch
-const mockFetch = jest.fn(() =>
-  Promise.resolve(new Response(JSON.stringify({}), {
-    status: 200,
-    headers: {
-      'Content-type': 'application/json',
-    },
-  }))
-);
-
-global.fetch = mockFetch;
-
-// Mock ResizeObserver
-global.ResizeObserver = class ResizeObserver {
-  observe() {}
-  unobserve() {}
-  disconnect() {}
-};
+// Add TextEncoder/TextDecoder
+global.TextEncoder = TextEncoder;
+global.TextDecoder = TextDecoder as typeof global.TextDecoder;
 
 // Mock IntersectionObserver
 global.IntersectionObserver = class IntersectionObserver implements IntersectionObserver {
   readonly root: Element | null = null;
-  readonly rootMargin: string = '0px';
-  readonly thresholds: ReadonlyArray<number> = [0];
+  readonly rootMargin: string = '';
+  readonly thresholds: ReadonlyArray<number> = [];
   
   constructor(callback: IntersectionObserverCallback, options?: IntersectionObserverInit) {}
-  
   observe(target: Element): void {}
   unobserve(target: Element): void {}
   disconnect(): void {}
   takeRecords(): IntersectionObserverEntry[] { return []; }
 };
-
-// Add TextEncoder/TextDecoder
-global.TextEncoder = TextEncoder;
-global.TextDecoder = TextDecoder as typeof global.TextDecoder;
-
-// Mock window.matchMedia
-Object.defineProperty(window, 'matchMedia', {
-  writable: true,
-  value: jest.fn().mockImplementation(query => ({
-    matches: false,
-    media: query,
-    onchange: null,
-    addListener: jest.fn(),
-    removeListener: jest.fn(),
-    addEventListener: jest.fn(),
-    removeEventListener: jest.fn(),
-    dispatchEvent: jest.fn(),
-  })),
-});
diff --git a/legacy/legacy-apis/emerge-core-api/emerge-core-api b/legacy/legacy-apis/emerge-core-api/emerge-core-api
index 87e1095..9dfae5d 160000
--- a/legacy/legacy-apis/emerge-core-api/emerge-core-api
+++ b/legacy/legacy-apis/emerge-core-api/emerge-core-api
@@ -1 +1 @@
-Subproject commit 87e10951c9c2517f1ca215c64974daa00eec3bf3
+Subproject commit 9dfae5db124890d21a60c6bc2c6e94616a54b0ab
diff --git a/workspace/emerge-config-gen/plans/generator-design.md b/workspace/emerge-config-gen/plans/generator-design.md
index 675f698..f7f46d5 100644
--- a/workspace/emerge-config-gen/plans/generator-design.md
+++ b/workspace/emerge-config-gen/plans/generator-design.md
@@ -1,13 +1,13 @@
 # Emerge Config Generator Design
 
 ## Overview
-A focused tool for generating configuration components and metadata from legacy-analyzer output and additional configuration.
+A focused tool for generating type-safe configuration components that integrate seamlessly with the existing emerge-config navigation system, using legacy-analyzer output and configuration metadata.
 
 ## Core Principles
-1. Single responsibility - metadata generation
-2. Clean interfaces with legacy-analyzer
-3. Declarative configuration
-4. Type-safe output
+1. Single responsibility - generating maintainable configuration components
+2. Seamless navigation integration - working with existing routing and layout patterns
+3. Type safety - leveraging TypeScript and schema validation throughout
+4. Developer experience - providing clear templates and consistent patterns
 
 ## Architecture
 
@@ -25,11 +25,11 @@ interface GeneratedType {
 }
 ```
 
-#### Metadata Configuration
+#### Component Configuration
 ```yaml
 # metadata/account-settings.yaml
-group: accounts
-section: categories
+section: accounts
+component: categories
 metadata:
   key: Account.Categories
   label: Account Categories
@@ -39,6 +39,9 @@ metadata:
   permissions:
     - config.account.read
     - config.account.write
+  navigation:
+    parent: accounts
+    order: 100
 layout:
   type: form
   sections:
@@ -47,461 +50,989 @@ layout:
         - name: defaultCategories
           label: Default Categories
           component: ListInput
+          validation:
+            - type: required
+              message: Default categories are required
     - title: Advanced
       fields:
         - name: categoryRules
           label: Category Rules
           component: JsonEditor
+          validation:
+            - type: schema
+              schema: categoryRules.schema.json
 ```
 
 ### 2. Generator Pipeline
 
 ```
-Input → Validation → Enrichment → Generation → Output
+Input → Validation → Generation → Integration
 ```
 
-#### Stage 1: Input
-- Read legacy-analyzer output
-- Parse metadata YAML
-- Load templates
+#### Stage 1: Input Processing
+- Parse legacy-analyzer types
+- Load component configuration
+- Validate schema compatibility
+- Merge type and config data
 
 #### Stage 2: Validation
-- Validate types exist
+- Verify type existence
 - Check metadata completeness
-- Verify template syntax
-- Ensure unique keys
+- Validate component structure
+- Ensure unique identifiers
+- Verify navigation paths
 
-#### Stage 3: Enrichment
-- Merge type info with metadata
-- Resolve component dependencies
-- Generate navigation data
+#### Stage 3: Generation
+- Create component files
+- Generate type definitions
 - Add validation rules
+- Create test files
 
-#### Stage 4: Generation
-- Generate component files
-- Create metadata files
-- Output navigation configs
-- Write documentation
+#### Stage 4: Integration
+- Update navigation registry
+- Generate route configurations
+- Create documentation
+- Update test suites
 
-### 3. Output Structure
+### 3. Component Organization
 
 ```
-output/
-├── components/
-│   ├── accounts/
-│   │   └── AccountCategoriesSection.tsx
-│   └── core/
-│       └── CoreSettingsSection.tsx
-├── metadata/
-│   ├── accounts.json
-│   └── core.json
-├── navigation/
-│   └── config-sections.ts
-└── docs/
-    └── generated-sections.md
+src/components/emerge-config/
+├── core/
+│   ├── CoreSettingsLanding.tsx
+│   ├── general/               # Generated
+│   │   ├── index.tsx         # Main component
+│   │   ├── types.ts          # Type definitions
+│   │   └── validation.ts     # Validation rules
+│   └── branding/             # Generated
+├── accounts/
+└── auth-security/
 ```
 
-### 4. Templates
+### 4. Test Generation
 
-#### Component Template
+#### Integration Test Templates
 ```typescript
-// templates/component.hbs
-import { EmergeConfigSection } from '../base/EmergeConfigSection';
-import { {{type.name}} } from '{{type.importPath}}';
+// template: __tests__/integration.test.tsx
+import { render, screen, fireEvent, waitFor } from '@testing-library/react';
+import { MemoryRouter } from 'react-router-dom';
+import { NavigationRegistry } from '@components/navigation';
+import { {{ComponentName}} } from '../{{ComponentFile}}';
+import { {{SettingsInterface}} } from '../types';
 
-export class {{className}} extends EmergeConfigSection<{{type.name}}> {
-    static metadata = {{{json metadata}}};
-    
-    // Auto-registration
-    static {
-        EmergeConfigSection.register(
-            {{className}}.metadata.key,
-            {{className}}
-        );
-    }
+const defaultSettings: {{SettingsInterface}} = {
+    // Generated from schema default values
+};
 
-    protected getDefaultValue(): {{type.name}} {
-        return {{{json defaultValue}}};
-    }
-    
-    protected getValidationRules(): ValidationRules {
-        return {{{json validationRules}}};
-    }
-    
-    protected getLayout(): LayoutDefinition {
-        return {{{json layout}}};
+const mockSettingsService = {
+    getValue: jest.fn(),
+    setValue: jest.fn(),
+    validate: jest.fn()
+};
+
+jest.mock('@services/settings', () => ({
+    __esModule: true,
+    SettingsService: {
+        getInstance: () => mockSettingsService
     }
-}
-```
+}));
 
-For details on the registration flow and navigation integration, see `component-registration-flow.md`.
+describe('{{ComponentName}} Integration', () => {
+    beforeEach(() => {
+        mockSettingsService.getValue.mockReturnValue(defaultSettings);
+        mockSettingsService.validate.mockReturnValue({ valid: true });
+    });
 
-#### Metadata Template
-```typescript
-// templates/metadata.hbs
-export const {{groupId}}Metadata = {
-    sections: {{{json sections}}},
-    navigation: {{{json navigation}}}
-};
-```
+    it('should load and display settings', async () => {
+        render(
+            <MemoryRouter>
+                <{{ComponentName}} />
+            </MemoryRouter>
+        );
+        
+        await waitFor(() => {
+            // Generated expectations based on schema
+        });
+    });
 
-## Implementation Steps
+    it('should handle validation errors', async () => {
+        mockSettingsService.validate.mockReturnValue({
+            valid: false,
+            errors: [
+                // Generated from schema validation rules
+            ]
+        });
 
-### 1. Core Infrastructure
-- Project setup
-- CLI framework
-- Template engine
-- File system utilities
+        render(
+            <MemoryRouter>
+                <{{ComponentName}} />
+            </MemoryRouter>
+        );
 
-### 2. Input Processing
-- Legacy-analyzer parser
-- YAML parser
-- Template loader
-- Type definitions
+        // Generated validation tests
+    });
+});
+```
 
-### 3. Generation Pipeline
-- Pipeline framework
-- Stage implementations
-- Error handling
-- Progress tracking
+#### Navigation Test Templates
+```typescript
+// template: __tests__/navigation.test.tsx
+import { NavigationRegistry } from '@components/navigation';
+import { register{{Section}}Components } from '../navigation';
 
-### 4. Output Generation
-- Component generator
-- Metadata generator
-- Navigation config
-- Documentation
+describe('{{Section}} Navigation', () => {
+    beforeEach(() => {
+        NavigationRegistry.clear();
+    });
 
-### 5. Testing & Validation
-- Unit tests
-- Integration tests
-- Template validation
-- Output verification
+    it('should register components in correct order', () => {
+        register{{Section}}Components();
+        const items = NavigationRegistry.getNavigationItems();
+        
+        // Generated navigation assertions
+    });
 
-## Test Generation
+    it('should maintain parent-child relationships', () => {
+        register{{Section}}Components();
+        const parent = NavigationRegistry.getItem('{{parentId}}');
+        const child = NavigationRegistry.getItem('{{childId}}');
+        
+        expect(child.parent).toBe(parent.id);
+    });
+});
+```
 
-### 1. Component Test Generation
+#### Component Test Template
 ```typescript
 // templates/component.test.hbs
 import { render, screen, fireEvent } from '@testing-library/react';
 import { {{className}} } from './{{className}}';
 import { mockSettingsService } from '../../../test/mocks';
+import { createMemoryRouter } from 'react-router-dom';
 
 describe('{{className}}', () => {
     beforeEach(() => {
         mockSettingsService.reset();
     });
 
-    // Generated from metadata
-    it('should render with correct title', () => {
+    // Core Component Tests
+    it('should render with correct metadata', () => {
         render(<{{className}} />);
         expect(screen.getByText('{{metadata.label}}')).toBeInTheDocument();
+        expect(screen.getByTestId('section-icon')).toHaveAttribute('data-icon', '{{metadata.icon}}');
     });
 
-    // Generated from type information
-    it('should validate required fields', async () => {
-        const component = render(<{{className}} />);
-        {{#each type.requiredFields}}
-        expect(await component.validateField('{{name}}')).toEqual({
-            valid: false,
-            error: '{{name}} is required'
-        });
-        {{/each}}
-    });
-
-    // Generated from schema
+    // Form Validation Tests
     {{#each type.properties}}
-    it('should handle {{name}} updates', async () => {
-        const component = render(<{{../className}} />);
-        const input = screen.getByLabelText('{{label}}');
+    it('should validate {{name}} field', async () => {
+        const { getByLabelText } = render(<{{../className}} />);
+        const input = getByLabelText('{{label}}');
         
-        // Generated test value based on type
-        const testValue = {{generateTestValue type}};
-        await fireEvent.change(input, { target: { value: testValue } });
+        // Test required field
+        {{#if required}}
+        fireEvent.change(input, { target: { value: '' } });
+        expect(await screen.findByText('{{name}} is required')).toBeInTheDocument();
+        {{/if}}
         
-        expect(mockSettingsService.updateSetting).toHaveBeenCalledWith(
-            '{{../metadata.key}}.{{name}}',
-            testValue
-        );
+        // Test validation rules
+        {{#each validation}}
+        fireEvent.change(input, { target: { value: {{generateInvalidValue type}} } });
+        expect(await screen.findByText('{{message}}')).toBeInTheDocument();
+        
+        fireEvent.change(input, { target: { value: {{generateValidValue type}} } });
+        expect(screen.queryByText('{{message}}')).not.toBeInTheDocument();
+        {{/each}}
     });
     {{/each}}
 
-    // Generated from validation rules
-    {{#each metadata.validation}}
-    it('should validate {{field}} according to rules', async () => {
-        const component = render(<{{../className}} />);
-        {{#each rules}}
-        expect(await component.validateField('{{../field}}', {{generateTestValue type invalid=true}}))
-            .toEqual({
-                valid: false,
-                error: '{{message}}'
-            });
-        expect(await component.validateField('{{../field}}', {{generateTestValue type valid=true}}))
-            .toEqual({
-                valid: true
-            });
-        {{/each}}
+    // Navigation Tests
+    it('should integrate with navigation', () => {
+        const router = createMemoryRouter([{
+            path: '{{routePath}}',
+            element: <{{className}} />
+        }]);
+        
+        render(router);
+        expect(router.state.location.pathname).toBe('{{routePath}}');
+    });
+
+    // Permission Tests
+    it('should respect permissions', () => {
+        mockSettingsService.setPermissions([]);
+        render(<{{className}} />);
+        expect(screen.getByText('Access Denied')).toBeInTheDocument();
+
+        mockSettingsService.setPermissions({{{json metadata.permissions}}});
+        render(<{{className}} />);
+        expect(screen.queryByText('Access Denied')).not.toBeInTheDocument();
     });
-    {{/each}}
 });
 ```
 
-### 2. Integration Test Generation
+#### Integration Test Template
 ```typescript
 // templates/integration.test.hbs
+import { render, screen, fireEvent } from '@testing-library/react';
+import { NavigationRegistry } from '@components/navigation';
+import { {{className}} } from './{{className}}';
+
 describe('{{className}} Integration', () => {
-    // Generated from dependencies
-    {{#each metadata.dependencies}}
-    it('should interact with {{this}}', async () => {
-        const component = render(<{{../className}} />);
-        const dependentSection = render(<{{this}} />);
-        
-        // Test interaction based on dependency type
-        {{#if (isDataDependency this)}}
-        await component.updateValue({ key: 'test' });
-        expect(dependentSection.getValue('key')).toBe('test');
-        {{/if}}
-        
-        {{#if (isVisibilityDependency this)}}
-        await component.updateValue({ visible: true });
-        expect(dependentSection.isVisible()).toBe(true);
-        {{/if}}
+    beforeEach(() => {
+        NavigationRegistry.clear();
     });
-    {{/each}}
-    
-    // Generated from service interactions
-    it('should handle service errors', async () => {
+
+    // Navigation Integration
+    it('should register routes correctly', () => {
+        const route = NavigationRegistry.getRoute('{{routePath}}');
+        expect(route).toBeDefined();
+        expect(route.meta.title).toBe('{{metadata.label}}');
+        expect(route.meta.permissions).toEqual({{{json metadata.permissions}}});
+    });
+
+    // Parent-Child Navigation
+    {{#if metadata.navigation.parent}}
+    it('should handle parent-child navigation', () => {
+        const parentRoute = NavigationRegistry.getRoute('{{metadata.navigation.parent}}');
+        expect(parentRoute.children).toContain('{{routePath}}');
+    });
+    {{/if}}
+
+    // Service Integration
+    it('should handle service interactions', async () => {
         mockSettingsService.simulateError('updateSetting');
-        const component = render(<{{className}} />);
+        const { getByLabelText } = render(<{{className}} />);
         
-        await component.updateValue({ test: true });
+        {{#with (firstProperty type.properties)}}
+        const input = getByLabelText('{{label}}');
+        await fireEvent.change(input, { target: { value: {{generateTestValue type}} } });
         expect(screen.getByText('Error updating settings')).toBeInTheDocument();
+        {{/with}}
     });
 });
 ```
 
-### 3. E2E Test Generation
+#### E2E Test Template
 ```typescript
 // templates/e2e.test.hbs
-describe('{{className}} E2E', () => {
-    // Generated from navigation metadata
-    it('should be accessible through navigation', async () => {
-        render(<App />);
-        await navigateTo('{{metadata.menuPath}}');
-        expect(screen.getByText('{{metadata.label}}')).toBeInTheDocument();
+import { test, expect } from '@playwright/test';
+
+test.describe('{{className}} E2E', () => {
+    test('should navigate through UI', async ({ page }) => {
+        await page.goto('/emerge-config');
+        
+        // Navigate through parent if exists
+        {{#if metadata.navigation.parent}}
+        await page.click('text={{parentLabel}}');
+        {{/if}}
+        
+        await page.click('text={{metadata.label}}');
+        await expect(page).toHaveURL(/.*{{routePath}}/);
     });
-    
-    // Generated from workflow metadata
-    {{#each metadata.workflows}}
-    it('should complete {{name}} workflow', async () => {
-        render(<App />);
-        {{#each steps}}
-        await {{action}}('{{target}}', {{generateTestValue type}});
-        expect(screen.getByText('{{expectation}}')).toBeInTheDocument();
+
+    test('should handle form submission', async ({ page }) => {
+        await page.goto('{{routePath}}');
+        
+        {{#each type.properties}}
+        await page.fill('[aria-label="{{label}}"]', {{generateTestValue type}});
         {{/each}}
+        
+        await page.click('text=Save');
+        await expect(page.getByText('Settings saved')).toBeVisible();
     });
-    {{/each}}
 });
 ```
 
-### 4. Test Utils Generation
+### 5. Component Templates
+
+#### Base Component Template
 ```typescript
-// templates/test-utils.hbs
-export const {{camelCase className}}TestUtils = {
-    // Generated from type
-    generateValidValue(): {{type.name}} {
+// template: {{ComponentName}}.tsx
+import React from 'react';
+import { EmergeConfigSection } from '@components/emerge-config/core';
+import { {{SettingsInterface}} } from './types';
+import { {{IconName}} } from '@mui/icons-material';
+
+export class {{ComponentName}} extends EmergeConfigSection<{{SettingsInterface}}> {
+    static metadata = {
+        key: '{{settingsKey}}',
+        title: '{{title}}',
+        description: '{{description}}',
+        icon: {{IconName}},
+        permissions: [{{permissions}}],
+        navigation: {
+            parent: '{{parentId}}',
+            order: {{order}}
+        }
+    };
+
+    protected getValidationRules() {
         return {
-            {{#each type.properties}}
-            {{name}}: {{generateTestValue type}},
-            {{/each}}
+            // Generated from schema
         };
-    },
-    
-    // Generated from validation rules
-    generateInvalidValue(): {{type.name}} {
+    }
+
+    protected getLayout() {
         return {
-            {{#each metadata.validation}}
-            {{field}}: {{generateTestValue type invalid=true}},
-            {{/each}}
+            // Generated from schema and metadata
         };
+    }
+
+    render() {
+        const value = this.getValue();
+        const { loading, error } = this.state;
+
+        if (loading) return <LinearProgress />;
+        if (error) return <Alert severity="error">{error}</Alert>;
+
+        return (
+            <Box sx={{ p: 2 }}>
+                <FormGroup>
+                    {/* Generated form fields */}
+                </FormGroup>
+            </Box>
+        );
+    }
+}
+```
+
+#### Navigation Registration Template
+```typescript
+// template: navigation.ts
+import { NavigationRegistry } from '@components/navigation';
+import { {{ComponentName}} } from './{{ComponentFile}}';
+
+export function register{{Section}}Components() {
+    // Register parent section if needed
+    NavigationRegistry.register({
+        id: '{{parentId}}',
+        path: '{{parentPath}}',
+        title: '{{parentTitle}}',
+        parent: '{{grandParentId}}',
+        order: {{parentOrder}},
+        element: null
+    });
+
+    // Register component
+    NavigationRegistry.register({
+        id: '{{id}}',
+        path: '{{path}}',
+        title: {{ComponentName}}.metadata.title,
+        parent: '{{parentId}}',
+        order: {{ComponentName}}.metadata.navigation.order,
+        permissions: {{ComponentName}}.metadata.permissions,
+        element: {{ComponentName}}
+    });
+}
+```
+
+#### Index Template
+```typescript
+// templates/index.hbs
+export { {{componentName}} } from './component';
+export { register{{routeName}} } from './registry';
+export type { {{typeName}} } from './types';
+```
+
+### 6. Output Structure
+
+```
+output/
+├── components/
+│   ├── core/
+│   │   ├── general/
+│   │   └── branding/
+│   └── accounts/
+├── routes/
+│   └── index.ts
+├── navigation/
+│   └── registry.ts
+└── docs/
+    └── generated-components.md
+```
+
+### 7. Test Infrastructure
+
+#### Test Runner Configuration
+```typescript
+// jest.config.ts
+export default {
+    roots: ['<rootDir>/src'],
+    testMatch: [
+        '**/__tests__/**/*.ts?(x)',
+        '**/?(*.)+(spec|test).ts?(x)'
+    ],
+    transform: {
+        '^.+\\.tsx?$': 'ts-jest'
     },
-    
-    // Generated from workflows
-    async completeWorkflow(name: string): Promise<void> {
-        const workflow = {{className}}.workflows[name];
-        for (const step of workflow.steps) {
-            await step.action(step.target, this.generateTestValue(step.type));
+    setupFilesAfterEnv: [
+        '<rootDir>/src/test/setup.ts'
+    ],
+    moduleNameMapper: {
+        '^@emerge/(.*)$': '<rootDir>/src/$1'
+    }
+};
+```
+
+#### Test Setup
+```typescript
+// test/setup.ts
+import '@testing-library/jest-dom';
+import { mockNavigationRegistry } from './mocks/navigation';
+import { mockSettingsService } from './mocks/settings';
+
+beforeEach(() => {
+    mockNavigationRegistry.clear();
+    mockSettingsService.reset();
+});
+```
+
+#### Test Utils
+```typescript
+// test/utils.ts
+export const testUtils = {
+    generateTestValue(type: TypeInfo, options: TestValueOptions = {}): any {
+        return options.invalid 
+            ? generateInvalidValue(type)
+            : generateValidValue(type);
+    },
+
+    async navigateToComponent(page: Page, path: string) {
+        await page.goto('/emerge-config');
+        for (const segment of path.split('/')) {
+            await page.click(`text=${segment}`);
+        }
+    },
+
+    async validateNavigation(page: Page, route: string) {
+        await expect(page).toHaveURL(new RegExp(`.*${route}`));
+        await expect(page.getByTestId('navigation-title')).toBeVisible();
+    },
+
+    async fillSettingsForm(page: Page, values: Record<string, any>) {
+        for (const [label, value] of Object.entries(values)) {
+            await page.fill(`[aria-label="${label}"]`, String(value));
         }
+        await page.click('text=Save');
+    }
+};
+```
+
+#### Mock Services
+```typescript
+// test/mocks/settings.ts
+export const mockSettingsService = {
+    values: new Map<string, any>(),
+    permissions: new Set<string>(),
+
+    reset() {
+        this.values.clear();
+        this.permissions.clear();
+    },
+
+    setValue(key: string, value: any) {
+        this.values.set(key, value);
+    },
+
+    getValue(key: string) {
+        return this.values.get(key);
+    },
+
+    setPermissions(permissions: string[]) {
+        this.permissions = new Set(permissions);
+    },
+
+    hasPermission(permission: string) {
+        return this.permissions.has(permission);
+    },
+
+    simulateError(method: string) {
+        this[method] = () => {
+            throw new Error('Simulated error');
+        };
+    }
+};
+
+// test/mocks/navigation.ts
+export const mockNavigationRegistry = {
+    routes: new Map<string, RouteConfig>(),
+    
+    clear() {
+        this.routes.clear();
+    },
+    
+    register(route: RouteConfig) {
+        this.routes.set(route.path, route);
+    },
+    
+    getRoute(path: string) {
+        return this.routes.get(path);
+    },
+    
+    getAllRoutes() {
+        return Array.from(this.routes.values());
     }
 };
 ```
 
-### 5. Test Data Generation
+### 8. CI Integration
+
 ```yaml
-# templates/test-data.hbs
-{{className}}TestData:
-  valid:
-    {{#each type.properties}}
-    {{name}}: {{generateTestValue type}}
-    {{/each}}
-  
-  invalid:
-    {{#each metadata.validation}}
-    {{field}}:
-      {{#each rules}}
-      - value: {{generateTestValue type invalid=true}}
-        error: "{{message}}"
-      {{/each}}
-    {{/each}}
-  
-  workflows:
-    {{#each metadata.workflows}}
-    {{name}}:
-      {{#each steps}}
-      - action: {{action}}
-        value: {{generateTestValue type}}
-        expect: {{expectation}}
-      {{/each}}
-    {{/each}}
+# .github/workflows/test.yml
+name: Test
+on: [push, pull_request]
+
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v2
+      - name: Setup Node.js
+        uses: actions/setup-node@v2
+        with:
+          node-version: '18'
+      
+      - name: Install Dependencies
+        run: npm ci
+      
+      - name: Generate Components
+        run: npm run generate
+      
+      - name: Run Unit Tests
+        run: npm run test:unit
+      
+      - name: Run Integration Tests
+        run: npm run test:integration
+      
+      - name: Run E2E Tests
+        run: npm run test:e2e
 ```
 
-### Test Generation Pipeline
-
-1. **Metadata Analysis**
-   - Extract testable properties
-   - Identify validation rules
-   - Map dependencies
-   - Define workflows
-
-2. **Template Selection**
-   - Choose appropriate templates
-   - Resolve dependencies
-   - Include test utilities
-
-3. **Test Value Generation**
-   ```typescript
-   function generateTestValue(type: TypeInfo, options: TestValueOptions = {}): any {
-       switch (type.kind) {
-           case 'string':
-               return options.invalid 
-                   ? generateInvalidString(type.constraints)
-                   : generateValidString(type.constraints);
-           case 'number':
-               return options.invalid
-                   ? generateInvalidNumber(type.constraints)
-                   : generateValidNumber(type.constraints);
-           // ... other types
-       }
-   }
-   ```
-
-4. **Test Organization**
-   ```typescript
-   export interface TestSuite {
-       unit: {
-           component: string[];
-           hooks: string[];
-           utils: string[];
-       };
-       integration: {
-           dependencies: string[];
-           services: string[];
-       };
-       e2e: {
-           workflows: string[];
-           navigation: string[];
-       };
-   }
-   ```
-
-### Test Running Infrastructure
-
-1. **Test Runner Configuration**
-   ```typescript
-   // jest.config.generated.js
-   module.exports = {
-       roots: ['<rootDir>/src'],
-       testMatch: [
-           '**/__tests__/**/*.generated.ts?(x)',
-           '**/?(*.)+(spec|test).generated.ts?(x)'
-       ],
-       transform: {
-           '^.+\\.tsx?$': 'ts-jest'
-       },
-       setupFilesAfterEnv: [
-           '<rootDir>/src/test/generated-setup.ts'
-       ]
-   };
-   ```
-
-2. **Test Environment Setup**
-   ```typescript
-   // test/generated-setup.ts
-   import { ConfigSectionRegistry } from '../components/config';
-   import { mockSettingsService } from './mocks';
-   
-   beforeEach(() => {
-       ConfigSectionRegistry.clear();
-       mockSettingsService.reset();
-   });
-   ```
-
-3. **CI Integration**
-   ```yaml
-   # .github/workflows/test-generated.yml
-   name: Generated Tests
-   on: [push, pull_request]
-   jobs:
-     test:
-       runs-on: ubuntu-latest
-       steps:
-         - uses: actions/checkout@v2
-         - name: Generate Tests
-           run: npm run generate:tests
-         - name: Run Generated Tests
-           run: npm run test:generated
-   ```
-
-### Test Generation CLI
+### 9. CLI Interface
 
+#### Command Structure
 ```bash
-# Generate all tests
-emerge-config-gen generate:tests \
-  --metadata ./metadata \
-  --output ./src/__tests__/generated
+emerge-config-gen <command> [options]
+```
 
-# Generate specific test types
-emerge-config-gen generate:tests \
-  --type unit,integration \
-  --section AccountSettings
+#### Available Commands
 
-# Watch mode for test generation
-emerge-config-gen watch:tests \
-  --metadata ./metadata
+1. **Generate Component**
+```bash
+emerge-config-gen generate component \
+  --section accounts \
+  --name categories \
+  --schema ../legacy-analyzer/output/Account.Categories.json \
+  --output src/components/emerge-config
 ```
 
-## Usage Example
+2. **Generate Navigation**
+```bash
+emerge-config-gen generate navigation \
+  --input src/components/emerge-config \
+  --output src/navigation
+```
 
+3. **Watch Mode**
 ```bash
-# Generate from legacy output
-emerge-config-gen generate \
-  --legacy-output ../legacy-analyzer/output \
-  --metadata ./metadata \
-  --templates ./templates \
-  --output ../cbp-admin/src/components/emerge-config
-
-# Watch mode for development
 emerge-config-gen watch \
-  --legacy-output ../legacy-analyzer/output \
-  --metadata ./metadata
+  --section accounts \
+  --schema ../legacy-analyzer/output \
+  --output src/components/emerge-config
+```
 
-# Validate only
+4. **Validate**
+```bash
 emerge-config-gen validate \
-  --metadata ./metadata
+  --section accounts \
+  --name categories
+```
+
+#### Configuration File
+```yaml
+# emerge-config.yaml
+generator:
+  input:
+    schemaDir: ../legacy-analyzer/output
+    templates: ./templates
+  output:
+    components: src/components/emerge-config
+    navigation: src/navigation
+    docs: docs/generated
+  validation:
+    strict: true
+    checkPermissions: true
+  navigation:
+    baseRoute: /emerge-config
+    defaultIcon: SettingsIcon
+```
+
+### 10. Usage Examples
+
+#### 1. Basic Component Generation
+```bash
+# Generate a single component
+emerge-config-gen generate component \
+  --section core \
+  --name general \
+  --schema ../legacy-analyzer/output/Core.General.json
+
+# Generate all components in a section
+emerge-config-gen generate section \
+  --section accounts \
+  --schema ../legacy-analyzer/output/accounts/*.json
+```
+
+#### 2. Navigation Integration
+```bash
+# Generate navigation for all components
+emerge-config-gen generate navigation
+
+# Update specific section's navigation
+emerge-config-gen generate navigation \
+  --section accounts
+
+# Validate navigation structure
+emerge-config-gen validate navigation
+```
+
+#### 3. Development Workflow
+```bash
+# Start watch mode for development
+emerge-config-gen watch \
+  --section accounts \
+  --schema ../legacy-analyzer/output/accounts/*.json
+
+# Run component validation
+emerge-config-gen validate \
+  --section accounts \
+  --name categories
+
+# Run navigation validation
+emerge-config-gen validate navigation
+```
+
+#### 4. Testing
+```bash
+# Generate and run tests
+emerge-config-gen generate tests \
+  --section accounts \
+  --name categories
+
+# Run specific test types
+npm run test:unit
+npm run test:integration
+npm run test:e2e
+```
+
+### 11. Next Steps
+
+1. **Core Implementation**
+   - [ ] Set up project structure
+   - [ ] Implement CLI framework
+   - [ ] Create base templates
+   - [ ] Add validation logic
+
+2. **Navigation Integration**
+   - [ ] Implement route generation
+   - [ ] Add navigation registry
+   - [ ] Create permission handling
+   - [ ] Test navigation flows
+
+3. **Testing Infrastructure**
+   - [ ] Set up Jest configuration
+   - [ ] Create test templates
+   - [ ] Add navigation mocks
+   - [ ] Configure CI pipeline
+
+4. **Documentation**
+   - [ ] Create usage guides
+   - [ ] Document navigation structure
+   - [ ] Add component examples
+   - [ ] Include testing guides
+
+5. **Validation**
+   - [ ] Create proof of concept
+   - [ ] Test with existing components
+   - [ ] Validate navigation structure
+   - [ ] Review performance
+
+### 4. Templates
+
+#### Component Template
+```typescript
+// templates/component.hbs
+import { EmergeConfigSection } from '../base/EmergeConfigSection';
+import { {{type.name}} } from '{{type.importPath}}';
+import { useNavigate } from 'react-router-dom';
+
+export class {{className}} extends EmergeConfigSection<{{type.name}}> {
+    static metadata = {{{json metadata}}};
+    
+    protected getDefaultValue(): {{type.name}} {
+        return {{{json defaultValue}}};
+    }
+    
+    protected getValidationRules(): ValidationRules {
+        return {{{json validationRules}}};
+    }
+
+    render() {
+        return (
+            <ConfigSection
+                title={{{className}}.metadata.label}
+                description={{{className}}.metadata.description}
+                icon={{{className}}.metadata.icon}
+            >
+                <SettingsForm
+                    value={this.getValue()}
+                    onChange={this.setValue}
+                    validation={this.getValidationRules()}
+                    layout={this.getLayout()}
+                />
+            </ConfigSection>
+        );
+    }
+}
 ```
 
-## Next Steps
-1. Create project structure
-2. Implement core pipeline
-3. Design template system
-4. Add validation logic
-5. Create initial templates
+### 5. Navigation Integration
+
+#### Route Template
+```typescript
+// templates/route.hbs
+export const {{routeName}}Route: RouteConfig = {
+    id: '{{routeId}}',
+    path: '{{routePath}}',
+    title: '{{metadata.label}}',
+    element: {{componentName}},
+    icon: {{metadata.icon}},
+    parent: '{{parentRoute}}',
+    permissions: {{json metadata.permissions}}
+};
+```
+
+#### Navigation Registry
+```typescript
+// templates/registry.hbs
+import { NavigationRegistry } from '@emerge/core';
+import { {{routeName}}Route } from './route';
+
+export function register{{routeName}}() {
+    NavigationRegistry.register({{routeName}}Route);
+}
+```
+
+#### Index Template
+```typescript
+// templates/index.hbs
+export { {{componentName}} } from './component';
+export { register{{routeName}} } from './registry';
+export type { {{typeName}} } from './types';
+```
+
+### 6. POC Implementation Learnings
+
+#### Updated Component Template
+```typescript
+// templates/component.tsx.hbs
+import React from 'react';
+import { EmergeConfigSection } from '@components/emerge-config/core';
+import { {{type.name}} } from './types';
+import { {{iconName}} } from '@mui/icons-material';
+import { Box, FormGroup, LinearProgress, Alert } from '@mui/material';
+
+export class {{className}} extends EmergeConfigSection<{{type.name}}> {
+    static metadata = {
+        key: '{{settingsKey}}',
+        title: '{{title}}',
+        description: '{{description}}',
+        icon: {{iconName}},
+        permissions: [{{permissions}}],
+        navigation: {
+            parent: '{{parentId}}',
+            order: {{order}}
+        }
+    };
+
+    protected getValidationRules(): ValidationRules {
+        return {
+            {{#each validationRules}}
+            {{@key}}: {
+                {{#each this}}
+                {{@key}}: {{json this}},
+                {{/each}}
+            },
+            {{/each}}
+        };
+    }
+
+    protected getLayout(): LayoutDefinition {
+        return {
+            {{#each layout}}
+            {{@key}}: {
+                {{#each this}}
+                {{@key}}: {{json this}},
+                {{/each}}
+            },
+            {{/each}}
+        };
+    }
+
+    render() {
+        const value = this.getValue();
+        const { loading, error } = this.state;
+
+        if (loading) return <LinearProgress />;
+        if (error) return <Alert severity="error">{error}</Alert>;
+
+        return (
+            <Box sx={{ p: 2 }}>
+                <FormGroup>
+                    {{#each fields}}
+                    <{{componentType}}
+                        value={value.{{name}}}
+                        onChange={(newValue) => this.handleFieldChange('{{name}}', newValue)}
+                        {{#each props}}
+                        {{@key}}={{{json this}}}
+                        {{/each}}
+                    />
+                    {{/each}}
+                </FormGroup>
+            </Box>
+        );
+    }
+}
+```
+
+#### Updated Navigation Template
+```typescript
+// templates/navigation.ts.hbs
+import { NavigationRegistry } from '@components/navigation';
+{{#each components}}
+import { {{name}} } from './{{file}}';
+{{/each}}
+
+export function register{{section}}Components() {
+    // Register parent sections
+    {{#each parents}}
+    NavigationRegistry.register({
+        id: '{{id}}',
+        path: '{{path}}',
+        title: '{{title}}',
+        parent: '{{parent}}',
+        order: {{order}},
+        element: null
+    });
+    {{/each}}
+
+    // Register components
+    {{#each components}}
+    NavigationRegistry.register({
+        id: '{{id}}',
+        path: '{{path}}',
+        title: {{name}}.metadata.title,
+        parent: '{{parent}}',
+        order: {{name}}.metadata.navigation.order,
+        permissions: {{name}}.metadata.permissions,
+        element: {{name}}
+    });
+    {{/each}}
+}
+```
+
+#### Test Templates
+```typescript
+// templates/__tests__/component.test.tsx.hbs
+import React from 'react';
+import { render, screen, fireEvent, waitFor } from '@testing-library/react';
+import { MemoryRouter } from 'react-router-dom';
+import { {{className}} } from '../{{fileName}}';
+import { {{type.name}} } from '../types';
+
+const defaultValue: {{type.name}} = {
+    {{#each defaultValue}}
+    {{@key}}: {{json this}},
+    {{/each}}
+};
+
+const mockSettingsService = {
+    getValue: jest.fn(),
+    setValue: jest.fn(),
+    validate: jest.fn()
+};
+
+jest.mock('@services/settings', () => ({
+    __esModule: true,
+    SettingsService: {
+        getInstance: () => mockSettingsService
+    }
+}));
+
+describe('{{className}}', () => {
+    beforeEach(() => {
+        mockSettingsService.getValue.mockReturnValue(defaultValue);
+        mockSettingsService.validate.mockReturnValue({ valid: true });
+    });
+
+    it('should render and handle changes', async () => {
+        render(
+            <MemoryRouter>
+                <{{className}} />
+            </MemoryRouter>
+        );
+
+        {{#each testCases}}
+        {{#if this.input}}
+        fireEvent.change(screen.getByLabelText('{{this.label}}'), {
+            target: { value: {{json this.input}} }
+        });
+        {{/if}}
+        {{#if this.click}}
+        fireEvent.click(screen.getByLabelText('{{this.label}}'));
+        {{/if}}
+        {{#if this.select}}
+        fireEvent.click(screen.getByLabelText('{{this.label}}'));
+        fireEvent.click(screen.getByText('{{this.select}}'));
+        {{/if}}
+        {{/each}}
+
+        await waitFor(() => {
+            expect(mockSettingsService.setValue).toHaveBeenCalledWith(
+                {{className}}.metadata.key,
+                expect.objectContaining({
+                    {{#each expectedValue}}
+                    {{@key}}: {{json this}},
+                    {{/each}}
+                })
+            );
+        });
+    });
+});
+```
+
+### 7. Generator CLI Updates
+
+The generator CLI has been updated to support the new template structure and POC learnings:
+
+```bash
+# Generate a new settings component
+emerge-config-gen component create \
+    --name "notification-settings" \
+    --section "core" \
+    --title "Notification Settings" \
+    --description "Configure notification preferences" \
+    --icon NotificationsIcon \
+    --permissions "config.notifications.view,config.notifications.edit" \
+    --parent "emergeConfig-core" \
+    --order 1
+
+# Generate navigation registration
+emerge-config-gen navigation register \
+    --section "core" \
+    --output "src/components/emerge-config/core/navigation.ts"
+
+# Generate tests
+emerge-config-gen tests create \
+    --component "notification-settings" \
+    --section "core" \
+    --output "src/components/emerge-config/core/__tests__"
diff --git a/workspace/emerge-config-gen/plans/master-implementation.md b/workspace/emerge-config-gen/plans/master-implementation.md
index 0264bce..2e7dfe1 100644
--- a/workspace/emerge-config-gen/plans/master-implementation.md
+++ b/workspace/emerge-config-gen/plans/master-implementation.md
@@ -9,17 +9,17 @@ This implementation plan coordinates the designs specified in:
    - Input component system
    - Extension points
 
-2. **Navigation Design** (`cbp-admin/.cascade/plans/emerge-config-navigation.md`)
-   - URL structure
-   - Registry pattern
-   - Route generation
-   - Menu integration
+2. **Navigation Integration** (`cbp-admin/.cascade/plans/emerge-config-navigation.md`)
+   - Integration with existing navigation
+   - Route extension patterns
+   - Component placement guidelines
+   - Section organization
 
 3. **Generator Design** (`workspace/emerge-config-gen/plans/generator-design.md`)
    - Pipeline architecture
    - Template system
-   - Input/Output formats
-   - CLI interface
+   - Component generation
+   - Route integration
 
 4. **Base Component Pattern** (`cbp-admin/.cascade/patterns/emerge-config/base-component.md`)
    - Implementation patterns
@@ -33,16 +33,22 @@ This implementation plan coordinates the designs specified in:
    - Legacy integration
    - Migration support
 
+6. **Settings Service Refactor** (`workspace/legacy-analyzer/plans/settings-service-refactor.md`)
+   - TypeScript conversion
+   - API response types
+   - Validation rules
+   - Cache management
+
 ## System Components
-- **Base Component** (cbp-admin) - See `emerge-config-design.md`
-- **Navigation System** (cbp-admin) - See `emerge-config-navigation.md`
-- **Generator Tool** (emerge-config-gen) - See `generator-design.md`
-- **Service Layer** (cbp-admin) - See `settings-type-generation.md`
+- **Base Component** (cbp-admin) - Core functionality for settings management
+- **Navigation Integration** (cbp-admin) - Integration with existing emerge-config navigation
+- **Generator Tool** (emerge-config-gen) - Component and route generation
+- **Service Layer** (cbp-admin) - Settings management and validation
 
 ## Implementation Phases
 
 ### Phase 1: Foundation (Week 1)
-Focus: Core infrastructure and validation patterns
+Focus: Core infrastructure and base component implementation
 Reference: `emerge-config-design.md#base-component-architecture`
 
 #### 1.1 Base Component Core
@@ -51,22 +57,12 @@ Reference: `emerge-config-design.md#base-component-architecture`
 - [ ] Add basic validation system
 - [ ] Write unit tests
 ```typescript
-// Validation: Create test section
-class TestConfigSection extends EmergeConfigSection<TestConfig> {
-    static metadata = {
-        key: 'Test.Config',
-        label: 'Test Config'
-    };
+// Example: Base component implementation
+abstract class EmergeConfigSection<T> extends React.Component<ConfigSectionProps<T>> {
+    static metadata: ConfigMetadata;
+    protected abstract getDefaultValue(): T;
+    protected abstract getValidationRules(): ValidationRules;
 }
-
-// Expected: Should handle basic value management
-describe('TestConfigSection', () => {
-    it('should manage values correctly', async () => {
-        const section = new TestConfigSection();
-        await section.setValue({ test: true });
-        expect(section.getValue()).toEqual({ test: true });
-    });
-});
 ```
 
 #### 1.2 Service Layer Updates
@@ -74,244 +70,376 @@ describe('TestConfigSection', () => {
 - [ ] Implement type validation
 - [ ] Create test helpers
 ```typescript
-// Validation: Test schema validation
+// Example: Service integration
 describe('SettingsService', () => {
     it('should validate against schema', async () => {
-        const result = await service.validateSetting('test', {
-            value: 'invalid'
-        });
+        const result = await service.validateSetting('test', { value: 'invalid' });
         expect(result.errors).toBeDefined();
     });
 });
 ```
 
-### Phase 2: Generator Foundation (Week 1-2)
-Focus: Basic generation pipeline and template system
-Reference: `generator-design.md#generator-pipeline`
+### Phase 2: Navigation Integration (Week 1-2)
+Focus: Integration with existing emerge-config navigation
+Reference: `emerge-config-navigation.md`
 
-#### 2.1 Generator Core
-- [ ] Setup project structure
-- [ ] Implement basic pipeline
-- [ ] Create template engine
+#### 2.1 Route Integration
+- [ ] Analyze existing route structure
+- [ ] Create route extension patterns
+- [ ] Implement component placement
 ```typescript
-// Validation: Generate simple component
-const output = await generator.generateComponent({
-    type: 'TestConfig',
-    metadata: {
-        key: 'Test.Config',
-        label: 'Test'
-    }
-});
-
-// Expected: Should match template
-expect(output).toContain('extends EmergeConfigSection');
+// Example: Route integration
+const generatedRoute = {
+    id: 'emergeConfig-core-general',
+    path: 'general',
+    title: 'General Settings',
+    element: CoreGeneralSettings,
+    parent: 'emergeConfig-core'
+};
 ```
 
-#### 2.2 Legacy Integration
-- [ ] Parse legacy-analyzer output
-- [ ] Map types to components
-- [ ] Generate validation rules
-```yaml
-# Validation: Create test metadata
-group: test
-section: config
-metadata:
-  key: Test.Config
-  type: TestConfig  # Should match legacy type
+#### 2.2 Component Integration
+- [ ] Create section wrapper components
+- [ ] Implement layout system
+- [ ] Add navigation helpers
+```typescript
+// Example: Component integration
+const GeneratedSettingsComponent = () => (
+    <ConfigSection>
+        <SettingsForm
+            value={value}
+            onChange={setValue}
+            validation={validationRules}
+        />
+    </ConfigSection>
+);
 ```
 
-### Phase 3: Navigation & Registry (Week 2)
-Focus: Component discovery and routing
-Reference: `emerge-config-navigation.md#section-registry`
+### Phase 3: Generator Implementation (Week 2-3)
+Focus: Component and route generation
+Reference: `generator-design.md`
 
-#### 3.1 Section Registry
-- [ ] Implement registry pattern
-- [ ] Add auto-registration
-- [ ] Create test utilities
+#### 3.1 Generator Core
+- [ ] Setup project structure
+- [ ] Implement template system
+- [ ] Create component generator
 ```typescript
-// Validation: Test registration
-describe('ConfigSectionRegistry', () => {
-    it('should auto-register sections', () => {
-        const section = registry.getSection('test.config');
-        expect(section).toBeDefined();
-    });
-});
+// Example: Component generation
+emerge-config-gen create \
+  --section core \
+  --name general-settings \
+  --schema schema.json \
+  --output src/components/emerge-config/core
 ```
 
-#### 3.2 Navigation Integration
+#### 3.2 Integration Generation
 - [ ] Add route generation
-- [ ] Implement section wrapper
-- [ ] Create navigation provider
+- [ ] Implement navigation integration
+- [ ] Create test generators
 ```typescript
-// Validation: Test routing
-describe('ConfigSectionWrapper', () => {
-    it('should load correct section', () => {
-        render(<ConfigSectionWrapper path="/test/config" />);
-        expect(screen.getByText('Test Config')).toBeInTheDocument();
+// Example: Generated integration
+export class CoreGeneralSettings extends EmergeConfigSection<GeneralConfig> {
+    static metadata = {
+        key: 'Core.General',
+        label: 'General Settings'
+    };
+}
+```
+
+### Phase 4: Testing & Validation (Week 3-4)
+Focus: Comprehensive testing and documentation
+Reference: All design documents
+
+#### 4.1 Component Testing
+- [ ] Unit test base component
+- [ ] Test validation system
+- [ ] Verify type safety
+```typescript
+// Example: Component test
+describe('EmergeConfigSection', () => {
+    it('should enforce type safety', () => {
+        const section = new TestConfigSection();
+        expect(() => section.setValue(invalidValue)).toThrow();
     });
 });
 ```
 
-### Phase 4: Full Pipeline (Week 2-3)
-Focus: End-to-end generation and integration
-Reference: `generator-design.md#output-structure`
-
-#### 4.1 Complete Generator
-- [ ] Add all template types
-- [ ] Implement full validation
-- [ ] Generate documentation
-```bash
-# Validation: Generate full section
-emerge-config-gen generate --test-mode
-# Expected: Should create all files
-ls -la output/
-  components/test/TestConfigSection.tsx
-  metadata/test.json
-  navigation/config-sections.ts
+#### 4.2 Integration Testing
+- [ ] Test navigation flow
+- [ ] Verify route generation
+- [ ] Validate component integration
+```typescript
+// Example: Integration test
+describe('Navigation Integration', () => {
+    it('should maintain navigation state', async () => {
+        render(<ConfigNavigation />);
+        fireEvent.click(screen.getByText('Settings'));
+        expect(location.pathname).toBe('/emerge-config/settings');
+    });
+});
 ```
 
-#### 4.2 Integration Tests
-- [ ] Create test harness
-- [ ] Add e2e tests
-- [ ] Write integration tests
+#### 4.3 Generator Testing
+- [ ] Test template generation
+- [ ] Verify output structure
+- [ ] Validate generated code
 ```typescript
-// Validation: Test full pipeline
-describe('E2E Tests', () => {
-    it('should generate and load section', async () => {
-        // Generate component
-        await generator.generateSection('test.config');
-        
-        // Load in app
-        render(<ConfigSection id="test.config" />);
-        expect(screen.getByText('Test Config')).toBeInTheDocument();
+// Example: Generator test
+describe('Component Generation', () => {
+    it('should generate valid components', async () => {
+        const output = await generator.generateComponent(schema);
+        expect(output).toContain('extends EmergeConfigSection');
     });
 });
 ```
 
-### Phase 5: Polish & Documentation (Week 3)
-Focus: Developer experience and production readiness
-Reference: `base-component.md#testing-requirements`
+## POC Implementation Learnings
 
-#### 5.1 Developer Tools
-- [ ] Add watch mode
-- [ ] Create debug tools
-- [ ] Improve error messages
+### 1. Component Architecture
+#### Base Component Structure
 ```typescript
-// Validation: Test developer experience
-describe('Developer Tools', () => {
-    it('should provide helpful errors', () => {
-        const error = generator.validateMetadata({});
-        expect(error.message).toContain('Missing required field');
-    });
-});
+abstract class EmergeConfigSection<T extends ConfigValue> {
+    static metadata: ConfigMetadata;
+    abstract getNavigationItem(): NavigationItem;
+    abstract getValidationRules(): ValidationRules;
+    abstract getLayout(): LayoutDefinition;
+    
+    // Core functionality
+    protected loadConfig(): Promise<void>;
+    protected saveConfig(config: T): Promise<void>;
+    private validateConfig(config: T): Promise<ValidationResult>;
+}
 ```
 
-#### 5.2 Production Preparation
-- [ ] Add performance tests
-- [ ] Create migration guide
-- [ ] Write documentation
+#### Component Metadata
 ```typescript
-// Validation: Performance benchmarks
-describe('Performance', () => {
-    it('should generate quickly', async () => {
-        const start = Date.now();
-        await generator.generateAll();
-        expect(Date.now() - start).toBeLessThan(5000);
-    });
+interface ConfigMetadata {
+    key: string;
+    title: string;
+    description: string;
+    icon: React.ComponentType;
+    permissions: string[];
+    navigation: {
+        parent: string;
+        order: number;
+    };
+}
+```
+
+### 2. Type System Implementation
+#### Settings Interface Pattern
+```typescript
+// Example from NotificationSettings POC
+interface NotificationSettings {
+    enabled: boolean;
+    emailNotifications: boolean;
+    pushNotifications: boolean;
+    frequency: 'realtime' | 'daily' | 'weekly';  // Union type for enums
+    categories: string[];  // Array type
+}
+```
+
+#### Validation Rules Pattern
+```typescript
+interface ValidationRules {
+    [key: string]: {
+        required?: boolean;
+        oneOf?: any[];
+        minItems?: number;
+        // Additional validation rules...
+    };
+}
+```
+
+### 3. Navigation Integration
+#### Registration Pattern
+```typescript
+NavigationRegistry.register({
+    id: 'emergeConfig-samples',
+    path: '/emerge-config/samples/poc',
+    title: 'POC Components',
+    parent: 'emergeConfig',
+    order: 1000,
+    element: null  // Parent sections don't need elements
+});
+
+NavigationRegistry.register({
+    id: 'emergeConfig-samples-notifications',
+    path: '/emerge-config/samples/poc/notifications',
+    title: NotificationSettingsConfig.metadata.title,
+    parent: 'emergeConfig-samples',
+    order: 1,
+    permissions: NotificationSettingsConfig.metadata.permissions,
+    element: NotificationSettingsConfig
 });
 ```
 
-## Validation Strategy
+### 4. Testing Strategy
+#### Integration Test Setup
+```typescript
+// Test wrapper for routing
+const TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {
+    return (
+        <MemoryRouter initialEntries={['/emerge-config/samples/poc']}>
+            {children}
+        </MemoryRouter>
+    );
+};
+
+// Mock settings service
+const mockSettingsService = {
+    getValue: jest.fn(),
+    setValue: jest.fn(),
+    validate: jest.fn()
+};
+
+jest.mock('@services/settings', () => ({
+    __esModule: true,
+    SettingsService: {
+        getInstance: () => mockSettingsService
+    }
+}));
+```
 
-### 1. Unit Testing
-Reference: `base-component.md#testing-requirements`
-- Each component has isolated tests
-- Mock dependencies
-- Test edge cases
-- Verify types
-
-### 2. Integration Testing
-Reference: `emerge-config-navigation.md#integration-points`
-- Test component interactions
-- Verify routing
-- Check data flow
-- Validate generation
-
-### 3. E2E Testing
-Reference: `generator-design.md#testing-requirements`
-- Full generation pipeline
+#### Test Coverage Requirements
+- Navigation integration
+  - Route registration
+  - Parent-child relationships
+  - Permission handling
+- Settings management
+  - Load/save operations
+  - Validation
+  - Error handling
 - Component rendering
-- Navigation flow
-- Form submission
-
-### 4. Manual Testing Points
-Reference: All design documents' testing sections
-After each phase:
-1. Generate test component
-2. Load in development
-3. Test interactions
-4. Verify types
-5. Check performance
+  - Form field interactions
+  - Validation feedback
+  - Loading states
+
+### 5. Implementation Requirements
+
+#### Required Base Components
+- `EmergeConfigSection`: Abstract base for all config sections
+- `ConfigSectionRegistry`: Manages section registration
+- `ValidationResult`: Common validation result structure
+- `SettingsService`: Singleton service for settings management
+
+#### Navigation Structure
+- Each config section must register with NavigationRegistry
+- Parent sections should be registered before children
+- Navigation metadata must include:
+  - Unique ID
+  - URL path
+  - Title
+  - Parent reference
+  - Order
+  - Permissions (if applicable)
+  - Element (component) reference
+
+#### Type Safety Requirements
+- All settings interfaces must extend ConfigValue
+- Enumerated values should use union types
+- Array types must specify element type
+- Validation rules must match interface structure
 
-## Success Criteria
-[Success criteria with links to relevant design sections]
-### Phase 1
-- [ ] Base component can manage values
-- [ ] Service layer validates JSON
-- [ ] Unit tests pass
-
-### Phase 2
-- [ ] Generator creates valid components
-- [ ] Templates work with legacy types
-- [ ] Test components compile
-
-### Phase 3
-- [ ] Registry finds components
-- [ ] Navigation loads sections
-- [ ] Routes work correctly
-
-### Phase 4
-- [ ] Full pipeline generates all files
-- [ ] Components work in app
-- [ ] E2E tests pass
-
-### Phase 5
-- [ ] Developer tools work
-- [ ] Performance meets targets
-- [ ] Documentation complete
+## Validation Strategy
+
+### 1. Type Safety
+- Enforce TypeScript strict mode
+- Validate component props
+- Check generated types
+```typescript
+// Example: Type validation
+const validateTypes = (component: typeof EmergeConfigSection) => {
+    const instance = new component();
+    expectType<ConfigValue>(instance.getValue());
+};
+```
+
+### 2. Integration Validation
+- Test navigation flows
+- Verify state management
+- Check error boundaries
+```typescript
+// Example: Integration validation
+describe('Error Boundaries', () => {
+    it('should catch component errors', () => {
+        const error = new Error('Test');
+        render(<ErrorBoundary><ThrowError error={error} /></ErrorBoundary>);
+        expect(screen.getByText('Error occurred')).toBeInTheDocument();
+    });
+});
+```
+
+### 3. Generator Validation
+- Validate generated code
+- Check template consistency
+- Verify file structure
+```typescript
+// Example: Generator validation
+const validateOutput = async (output: GeneratedFiles) => {
+    expect(output.component).toBeDefined();
+    expect(output.types).toBeDefined();
+    expect(output.tests).toBeDefined();
+};
+```
 
 ## Risk Mitigation
-[Risk mitigation with references to design considerations]
+
 ### Technical Risks
 1. **Type Generation**
    - Early validation with legacy-analyzer
    - Strong typing in templates
    - Automated tests
 
-2. **Performance**
-   - Benchmark critical paths
-   - Optimize templates
-   - Cache where possible
+2. **Navigation Integration**
+   - Clear component boundaries
+   - State management testing
+   - Error recovery
 
-3. **Integration**
-   - Clear interfaces
-   - Version management
-   - Compatibility tests
+3. **Performance**
+   - Lazy loading
+   - Bundle optimization
+   - Cache management
 
 ### Process Risks
 1. **Complexity**
-   - Phase-based approach
+   - Clear documentation
+   - Modular design
    - Regular validation
-   - Clear success criteria
 
 2. **Dependencies**
-   - Mock interfaces early
-   - Parallel development
-   - Clear contracts
+   - Version management
+   - Compatibility tests
+   - Migration guides
+
+## Success Criteria
+
+### Phase 1: Foundation
+- [ ] Base component handles all value types
+- [ ] Validation system catches all errors
+- [ ] Type safety is enforced
+- [ ] Unit tests pass with >90% coverage
+
+### Phase 2: Navigation
+- [ ] Components integrate with existing navigation
+- [ ] Route generation works correctly
+- [ ] State management is reliable
+- [ ] Integration tests pass
+
+### Phase 3: Generator
+- [ ] Templates generate valid code
+- [ ] Output structure is correct
+- [ ] Generated components work
+- [ ] Generator tests pass
+
+### Phase 4: Validation
+- [ ] All test suites pass
+- [ ] Documentation is complete
+- [ ] Performance meets targets
+- [ ] Error handling works
 
 ## Next Steps
-[Implementation steps with links to detailed designs]
-1. Create Phase 1 tasks
-2. Setup test infrastructure
-3. Begin base component
-4. Plan first validation checkpoint
+1. Review and approve updated design
+2. Begin Phase 1 implementation
+3. Create POC for navigation integration
+4. Test generator with sample schema
diff --git a/workspace/legacy-analyzer/output/infrastructure/models/Psi/Data/Models/ClientConfigurationModels/WindowsService/PscuLogFileTransformServiceSettings.ts b/workspace/legacy-analyzer/output/infrastructure/models/Psi/Data/Models/ClientConfigurationModels/WindowsService/PscuLogFileTransformServiceSettings.ts
index 4682bd1..070d257 100644
--- a/workspace/legacy-analyzer/output/infrastructure/models/Psi/Data/Models/ClientConfigurationModels/WindowsService/PscuLogFileTransformServiceSettings.ts
+++ b/workspace/legacy-analyzer/output/infrastructure/models/Psi/Data/Models/ClientConfigurationModels/WindowsService/PscuLogFileTransformServiceSettings.ts
@@ -1,60 +1,165 @@
 import { Setting, ISettingsGroup, ISettingsMetadata } from '@models/base/types';
-export interface PscuLogFileTransformServiceSettingsConfig {
-    Filters: string;
-    InputFileFields: string;
-    OutputFileFields: string;
-    PathConfiguration: string;
+import { JsonSetting } from '@models/base/JsonSetting';
+
+export interface PscuFilter {
+    Name: string;
+    ValuesCausingInclusion: string;
+    ValuesCausingExclusion: string;
+    RequiresValue: boolean;
+    ErrorMessage: string;
+}
+
+export interface PscuInputField {
+    Name: string;
+    DataType: string;
+    EmptyAllowed: boolean;
+}
+
+export interface PscuOutputField {
+    Position: number;
+    WhitespaceLength: number;
+    Name: string;
+    CustomFormatter: string | null;
+    TruncateToLength: number;
+    TruncateFromPosition: string;
+    MinimumOutputLength: number;
+    MinimumOutputPadFromPosition: string;
+    OutputFormatString: string;
+    StaticTextValue: string;
+}
+
+export interface PscuPathConfig {
+    InputPath: string;
+    InputFilenamePattern: string;
+    OutputPath: string;
+    ErrorPath: string;
+    ProcessedPath: string;
+    CompletedPath: string;
+    OutputFilePrefix: string;
+    InputFileExclusiveAccessTimeout: string;
+}
+
+class FiltersSetting extends JsonSetting<PscuFilter[]> {
+    protected settingKey = 'PsiServices.PscuLogFileTransformService.Filters';
+    protected defaultValue: PscuFilter[] = [];
+}
+
+class InputFieldsSetting extends JsonSetting<PscuInputField[]> {
+    protected settingKey = 'PsiServices.PscuLogFileTransformService.InputFileFields';
+    protected defaultValue: PscuInputField[] = [];
+}
+
+class OutputFieldsSetting extends JsonSetting<PscuOutputField[]> {
+    protected settingKey = 'PsiServices.PscuLogFileTransformService.OutputFileFields';
+    protected defaultValue: PscuOutputField[] = [];
+}
+
+class PathConfigSetting extends JsonSetting<PscuPathConfig> {
+    protected settingKey = 'PsiServices.PscuLogFileTransformService.PathConfiguration';
+    protected defaultValue: PscuPathConfig = {
+        InputPath: '',
+        InputFilenamePattern: '',
+        OutputPath: '',
+        ErrorPath: '',
+        ProcessedPath: '',
+        CompletedPath: '',
+        OutputFilePrefix: '',
+        InputFileExclusiveAccessTimeout: '00:05:00'
+    };
 }
 
 export class PscuLogFileTransformServiceSettings implements ISettingsGroup {
     static readonly metadata: ISettingsMetadata = {
-        groupName: 'PscuLogFileTransformServiceSettings'
+        groupName: 'WindowsService.PscuLogFileTransformServiceSettings',
+        settings: {
+            'PsiServices.PscuLogFileTransformService.Filters': {
+                key: 'PsiServices.PscuLogFileTransformService.Filters',
+                type: 'json',
+                required: true
+            },
+            'PsiServices.PscuLogFileTransformService.InputFileFields': {
+                key: 'PsiServices.PscuLogFileTransformService.InputFileFields',
+                type: 'json',
+                required: true
+            },
+            'PsiServices.PscuLogFileTransformService.OutputFileFields': {
+                key: 'PsiServices.PscuLogFileTransformService.OutputFileFields',
+                type: 'json',
+                required: true
+            },
+            'PsiServices.PscuLogFileTransformService.PathConfiguration': {
+                key: 'PsiServices.PscuLogFileTransformService.PathConfiguration',
+                type: 'json',
+                required: true
+            }
+        }
     };
 
+    readonly key: string = 'WindowsService.PscuLogFileTransformServiceSettings';
+    readonly label: string = 'PSCU Log File Transform Service Settings';
+    readonly description: string = 'Configuration settings for the PSCU Log File Transform Service';
+    readonly isCollapsed: boolean = false;
+    readonly order: number = 0;
 
-            private _filters: string;
-            get filters(): string {
-                return this._filters;
-            }
-            set filters(value: string) {
-                this._filters = value;
-            }
-
-            private _inputFileFields: string;
-            get inputFileFields(): string {
-                return this._inputFileFields;
-            }
-            set inputFileFields(value: string) {
-                this._inputFileFields = value;
-            }
+    private readonly _filters = new FiltersSetting();
+    get filters(): PscuFilter[] {
+        return this._filters.value;
+    }
+    set filters(value: PscuFilter[]) {
+        this._filters.value = value;
+    }
 
-            private _outputFileFields: string;
-            get outputFileFields(): string {
-                return this._outputFileFields;
-            }
-            set outputFileFields(value: string) {
-                this._outputFileFields = value;
-            }
+    private readonly _inputFileFields = new InputFieldsSetting();
+    get inputFileFields(): PscuInputField[] {
+        return this._inputFileFields.value;
+    }
+    set inputFileFields(value: PscuInputField[]) {
+        this._inputFileFields.value = value;
+    }
 
-            private _pathConfiguration: string;
-            get pathConfiguration(): string {
-                return this._pathConfiguration;
-            }
-            set pathConfiguration(value: string) {
-                this._pathConfiguration = value;
-            }
+    private readonly _outputFileFields = new OutputFieldsSetting();
+    get outputFileFields(): PscuOutputField[] {
+        return this._outputFileFields.value;
+    }
+    set outputFileFields(value: PscuOutputField[]) {
+        this._outputFileFields.value = value;
+    }
 
+    private readonly _pathConfiguration = new PathConfigSetting();
+    get pathConfiguration(): PscuPathConfig {
+        return this._pathConfiguration.value;
+    }
+    set pathConfiguration(value: PscuPathConfig) {
+        this._pathConfiguration.value = value;
+    }
 
     constructor() {}
 
+    toSettings(): Setting[] {
+        return [
+            this._filters.toSetting(),
+            this._inputFileFields.toSetting(),
+            this._outputFileFields.toSetting(),
+            this._pathConfiguration.toSetting()
+        ];
+    }
 
-        toSettings(): Setting[] {
-            return [
-                { key: "PscuLogFileTransformServiceSettings.Filters", value: this._filters, dataType: 'string', label: "Filters" },
-                { key: "PscuLogFileTransformServiceSettings.InputFileFields", value: this._inputFileFields, dataType: 'string', label: "Input File Fields" },
-                { key: "PscuLogFileTransformServiceSettings.OutputFileFields", value: this._outputFileFields, dataType: 'string', label: "Output File Fields" },
-                { key: "PscuLogFileTransformServiceSettings.PathConfiguration", value: this._pathConfiguration, dataType: 'string', label: "Path Configuration" },
-            ];
+    fromSettings(settings: Setting[]): void {
+        for (const setting of settings) {
+            switch (setting.key) {
+                case this._filters.toSetting().key:
+                    this._filters.fromSetting(setting);
+                    break;
+                case this._inputFileFields.toSetting().key:
+                    this._inputFileFields.fromSetting(setting);
+                    break;
+                case this._outputFileFields.toSetting().key:
+                    this._outputFileFields.fromSetting(setting);
+                    break;
+                case this._pathConfiguration.toSetting().key:
+                    this._pathConfiguration.fromSetting(setting);
+                    break;
+            }
         }
-
+    }
 }
\ No newline at end of file
diff --git a/workspace/legacy-analyzer/plans/settings-service-refactor.md b/workspace/legacy-analyzer/plans/settings-service-refactor.md
index a0882c0..913f060 100644
--- a/workspace/legacy-analyzer/plans/settings-service-refactor.md
+++ b/workspace/legacy-analyzer/plans/settings-service-refactor.md
@@ -134,6 +134,164 @@ Each settings group will be generated as a single file following this pattern:
 - [ ] Configure TypeScript path aliases
 - [ ] Handle cross-project references
 
+## TypeScript Service Implementation
+
+### 1. Service Interface
+```typescript
+interface ISettingsService {
+    getValue<T extends ConfigValue>(key: string): Promise<T>;
+    setValue<T extends ConfigValue>(key: string, value: T): Promise<void>;
+    validate<T extends ConfigValue>(value: T): Promise<ValidationResult>;
+    batchGet(keys: string[]): Promise<Record<string, ConfigValue>>;
+    batchSet(values: Record<string, ConfigValue>): Promise<void>;
+}
+
+// Singleton implementation
+export class SettingsService implements ISettingsService {
+    private static instance: SettingsService;
+    
+    static getInstance(): SettingsService {
+        if (!SettingsService.instance) {
+            SettingsService.instance = new SettingsService();
+        }
+        return SettingsService.instance;
+    }
+}
+```
+
+### 2. Validation Types
+```typescript
+interface ValidationError {
+    field: string;
+    message: string;
+}
+
+interface ValidationResult {
+    valid: boolean;
+    errors?: ValidationError[];
+}
+
+interface ValidationRule {
+    required?: boolean;
+    oneOf?: any[];
+    minItems?: number;
+    maxItems?: number;
+    pattern?: string;
+    custom?: (value: any) => ValidationError | null;
+}
+
+interface ValidationRules {
+    [key: string]: ValidationRule;
+}
+```
+
+### 3. Mock Service Implementation
+```typescript
+export class MockSettingsService implements ISettingsService {
+    private store: Map<string, ConfigValue> = new Map();
+    private validationRules: Map<string, ValidationRules> = new Map();
+
+    getValue<T extends ConfigValue>(key: string): Promise<T> {
+        return Promise.resolve(this.store.get(key) as T);
+    }
+
+    setValue<T extends ConfigValue>(key: string, value: T): Promise<void> {
+        this.store.set(key, value);
+        return Promise.resolve();
+    }
+
+    validate<T extends ConfigValue>(value: T): Promise<ValidationResult> {
+        // Implementation based on POC validation patterns
+        const errors: ValidationError[] = [];
+        const rules = this.validationRules.get(value.constructor.name);
+        
+        if (rules) {
+            Object.entries(rules).forEach(([field, rule]) => {
+                const fieldValue = (value as any)[field];
+                
+                if (rule.required && !fieldValue) {
+                    errors.push({
+                        field,
+                        message: `${field} is required`
+                    });
+                }
+                
+                if (rule.oneOf && !rule.oneOf.includes(fieldValue)) {
+                    errors.push({
+                        field,
+                        message: `${field} must be one of: ${rule.oneOf.join(', ')}`
+                    });
+                }
+                
+                // Additional validation implementations...
+            });
+        }
+        
+        return Promise.resolve({
+            valid: errors.length === 0,
+            errors: errors.length > 0 ? errors : undefined
+        });
+    }
+
+    batchGet(keys: string[]): Promise<Record<string, ConfigValue>> {
+        const result: Record<string, ConfigValue> = {};
+        keys.forEach(key => {
+            const value = this.store.get(key);
+            if (value) result[key] = value;
+        });
+        return Promise.resolve(result);
+    }
+
+    batchSet(values: Record<string, ConfigValue>): Promise<void> {
+        Object.entries(values).forEach(([key, value]) => {
+            this.store.set(key, value);
+        });
+        return Promise.resolve();
+    }
+}
+```
+
+### 4. Test Helpers
+```typescript
+export const createMockSettingsService = () => {
+    const service = new MockSettingsService();
+    
+    // Helper to pre-populate store
+    const withValues = (values: Record<string, ConfigValue>) => {
+        Object.entries(values).forEach(([key, value]) => {
+            service.setValue(key, value);
+        });
+        return service;
+    };
+    
+    // Helper to set validation rules
+    const withValidation = (rules: Record<string, ValidationRules>) => {
+        Object.entries(rules).forEach(([key, value]) => {
+            service.setValidationRules(key, value);
+        });
+        return service;
+    };
+    
+    return {
+        service,
+        withValues,
+        withValidation
+    };
+};
+
+// Usage in tests
+const { service } = createMockSettingsService()
+    .withValues({
+        'notification-settings': defaultNotificationSettings
+    })
+    .withValidation({
+        'NotificationSettings': {
+            enabled: { required: true },
+            frequency: { oneOf: ['realtime', 'daily', 'weekly'] }
+        }
+    });
+```
+
 ## Configuration Plan
 
 ### 1. TypeScript Configuration
diff --git a/workspace/legacy-analyzer/plans/settings-type-generation.md b/workspace/legacy-analyzer/plans/settings-type-generation.md
index 403083b..d9688d0 100644
--- a/workspace/legacy-analyzer/plans/settings-type-generation.md
+++ b/workspace/legacy-analyzer/plans/settings-type-generation.md
@@ -1,7 +1,29 @@
 # Settings Type Generation Enhancement Plan
 
 ## Overview
-This document outlines the plan to enhance the settings type generation to include full JSON schema metadata, enabling transparent serialization/deserialization and type-safe configuration management.
+This document outlines the plan to enhance settings type generation to create a robust, type-safe configuration system that:
+
+1. **JSON Handling**:
+   - Leverages the `JsonSetting` base class for automated JSON serialization/deserialization
+   - Extracts and preserves JSON schemas from C# XML documentation
+   - Provides type-safe access to JSON configuration values
+
+2. **Service Layer Integration**:
+   - Implements `ISettingsGroup` interface for seamless service layer integration
+   - Preserves exact setting keys from C# `[SettingKey]` attributes
+   - Maintains proper metadata structure for `ISettingsService` compatibility
+
+3. **Type Safety and Validation**:
+   - Generates TypeScript interfaces from C# models
+   - Includes JSON schema validation
+   - Preserves validation rules and metadata
+   - Provides runtime type checking
+
+4. **Developer Experience**:
+   - Maintains clear separation between model and service layers
+   - Provides consistent patterns for settings management
+   - Enables IDE autocompletion and type checking
+   - Preserves documentation and examples
 
 ## Current State
 - Basic TypeScript interfaces are generated from C# models
@@ -11,7 +33,111 @@ This document outlines the plan to enhance the settings type generation to inclu
 
 ## Required Changes
 
-### 1. JSON Schema Extraction
+### 1. JsonSetting Class Generation
+Generate individual JsonSetting classes for each JSON field:
+
+```typescript
+class ${FieldName}Setting extends JsonSetting<${FieldType}> {
+    protected settingKey = '${SettingKeyAttribute}';
+    protected defaultValue: ${FieldType} = ${DefaultValue};
+    protected schema: JsonSchema = ${GeneratedSchema};
+}
+```
+
+### 2. Interface Generation
+Generate TypeScript interfaces from C# models with proper typing:
+
+```typescript
+export interface ${InterfaceName} {
+    ${Fields}: ${FieldTypes};
+}
+```
+
+### 3. Settings Class Generation
+Generate settings class implementing ISettingsGroup:
+
+```typescript
+export class ${ClassName} implements ISettingsGroup {
+    static readonly metadata: ISettingsMetadata = {
+        groupName: '${GroupName}',
+        settings: {
+            '${SettingKey}': {
+                key: '${SettingKey}',
+                type: 'json',
+                required: ${Required},
+                schema: ${JsonSchema}
+            }
+        }
+    };
+
+    readonly key: string = '${GroupName}';
+    readonly label: string = '${Label}';
+    readonly description: string = '${Description}';
+
+    private readonly _${fieldName} = new ${FieldName}Setting();
+    get ${fieldName}(): ${FieldType} {
+        return this._${fieldName}.value;
+    }
+    set ${fieldName}(value: ${FieldType}) {
+        this._${fieldName}.value = value;
+    }
+
+    toSettings(): Setting[] {
+        return [
+            this._${fieldName}.toSetting()
+        ];
+    }
+
+    fromSettings(settings: Setting[]): void {
+        for (const setting of settings) {
+            switch (setting.key) {
+                case this._${fieldName}.toSetting().key:
+                    this._${fieldName}.fromSetting(setting);
+                    break;
+            }
+        }
+    }
+}
+```
+
+### 4. Metadata Extraction
+Extract metadata from C# attributes and XML comments:
+
+```typescript
+interface SettingsMetadata {
+    // From class name and namespace
+    groupName: string;
+    
+    // From SettingKey attributes and schema
+    settings: {
+        [key: string]: {
+            key: string;        // From SettingKey
+            type: string;       // Always 'json' for JSON fields
+            required: boolean;  // From schema
+            schema: JsonSchema; // From XML comments
+        }
+    }
+}
+```
+
+### 5. Default Value Generation
+Generate default values from C# examples in XML comments:
+
+```typescript
+private generateDefaultValue(field: ParsedField): string {
+    const remarks = field.attributes.find(a => a.name === 'remarks')?.value;
+    if (remarks) {
+        try {
+            return JSON.stringify(JSON.parse(remarks));
+        } catch (e) {
+            logger.warn(`Failed to parse JSON example for ${field.name}`);
+        }
+    }
+    return '{}'; // or '[]' for arrays
+}
+```
+
+### 6. JSON Schema Extraction
 Update `SettingsGenerator` to extract JSON schemas from XML comments:
 
 ```typescript
@@ -43,7 +169,7 @@ class SettingsGenerator {
 }
 ```
 
-### 2. Schema Generation
+### 7. Schema Generation
 Enhance `JsonGenerator` to generate JSON schemas from examples:
 
 ```typescript
@@ -68,122 +194,183 @@ class JsonGenerator {
         
         return schema;
     }
-
-    private getJsonType(value: any): string {
-        if (Array.isArray(value)) return 'array';
-        if (value === null) return 'null';
-        if (typeof value === 'object') return 'object';
-        return typeof value;
-    }
 }
 ```
 
-### 3. Key Path Preservation
-Update settings generation to include key paths from attributes:
+### 8. Service Layer Integration
+Ensure generated classes align with the service layer's expectations:
 
 ```typescript
-interface SettingsMetadata {
-    groupName: string;
-    keyPaths: Record<string, string>;
-    schemas: Record<string, JsonSchema>;
+// Base types from service layer
+export interface Setting {
+    key: string;
+    value: string;
+    description?: string;
+    dataType: 'string' | 'number' | 'boolean' | 'json';
+    validation?: Record<string, any>;
 }
 
-class SettingsGenerator {
-    private extractKeyPath(field: ParsedField): string | undefined {
-        return field.attributes
-            .find(a => a.name === 'SettingKey')
-            ?.value
-            ?.replace(/['"]/g, '');
+export interface SettingGroup {
+    settings: Setting[];
+    metadata: {
+        __metadata?: Record<string, string>;
+        __validations?: Record<string, any>;
+        __display?: Record<string, any>;
+    };
+}
+
+// Generated class must implement these correctly
+export class ${ClassName} implements ISettingsGroup {
+    static readonly metadata: ISettingsMetadata = {
+        groupName: '${GroupName}',
+        settings: {
+            // Must match service layer Setting type
+            '${SettingKey}': {
+                key: '${SettingKey}',
+                type: 'json',
+                required: ${Required},
+                schema: ${JsonSchema},
+                validation: ${ValidationRules},
+                description: '${Description}'
+            }
+        },
+        // Must match service layer SettingGroup metadata
+        __metadata: {
+            groupType: '${GroupType}',
+            category: '${Category}'
+        },
+        __validations: {
+            // Group-level validation rules
+        },
+        __display: {
+            order: ${Order},
+            isCollapsed: ${IsCollapsed},
+            category: '${Category}'
+        }
+    };
+
+    // Must match service layer expectations
+    toSettings(): Setting[] {
+        const settings = [this._${fieldName}.toSetting()];
+        // Ensure each Setting matches service layer type
+        for (const setting of settings) {
+            setting.dataType = 'json';
+            setting.validation = this.constructor.metadata
+                .settings[setting.key].validation;
+            setting.description = this.constructor.metadata
+                .settings[setting.key].description;
+        }
+        return settings;
+    }
+
+    // Must handle service layer Setting type
+    fromSettings(settings: Setting[]): void {
+        // Validate settings match expected type
+        for (const setting of settings) {
+            if (setting.dataType !== 'json') {
+                throw new Error(`Invalid setting type for ${setting.key}`);
+            }
+        }
+        // Process settings
+        for (const setting of settings) {
+            switch (setting.key) {
+                case this._${fieldName}.toSetting().key:
+                    this._${fieldName}.fromSetting(setting);
+                    break;
+            }
+        }
     }
 }
 ```
 
-### 4. Enhanced Type Generation
-Generate richer TypeScript interfaces with metadata:
+### 9. Settings Service Integration
+Ensure generated code works with ISettingsService:
 
 ```typescript
-// Generated output example
-export interface FilterConfig {
-    Name: string;
-    ValuesCausingInclusion: string;
-    ValuesCausingExclusion: string;
-    RequiresValue: boolean;
-    ErrorMessage: string;
+export interface ISettingsService {
+    getSettings(group: string): Promise<Setting[]>;
+    updateSettings(settings: Setting[]): Promise<void>;
 }
 
-export class PscuLogFileTransformServiceSettings implements ISettingsGroup {
-    static readonly metadata: ISettingsMetadata = {
-        groupName: 'PscuLogFileTransformServiceSettings',
-        keyPaths: {
-            filters: 'PsiServices.PscuLogFileTransformService.Filters'
-        },
-        schemas: {
-            filters: {
-                type: 'array',
-                items: {
-                    type: 'object',
-                    properties: {
-                        Name: { type: 'string' },
-                        ValuesCausingInclusion: { type: 'string' },
-                        ValuesCausingExclusion: { type: 'string' },
-                        RequiresValue: { type: 'boolean' },
-                        ErrorMessage: { type: 'string' }
-                    },
-                    required: ['Name', 'RequiresValue']
-                }
-            }
-        }
-    };
+// Generated usage example
+export class ${ClassName}Service {
+    constructor(private settingsService: ISettingsService) {}
 
-    // Type-safe accessors
-    get filters(): FilterConfig[] {
-        return JSON.parse(this._filters);
+    async load(): Promise<${ClassName}> {
+        const settings = await this.settingsService.getSettings(
+            ${ClassName}.metadata.groupName
+        );
+        const instance = new ${ClassName}();
+        instance.fromSettings(settings);
+        return instance;
     }
-    
-    set filters(value: FilterConfig[]) {
-        this._filters = JSON.stringify(value);
+
+    async save(instance: ${ClassName}): Promise<void> {
+        const settings = instance.toSettings();
+        await this.settingsService.updateSettings(settings);
     }
 }
 ```
 
 ## Implementation Steps
 
-1. **Schema Extraction**
-   - Add JSON schema type definitions
-   - Implement XML comment parsing
-   - Add schema extraction logic
-   - Add error handling for malformed JSON
+1. **Infrastructure Updates**
+   - Use JsonSetting base class for all JSON fields
+   - Implement ISettingsGroup interface properly
+   - Add metadata generation support
+   - Add JSON schema support to JsonSetting
+   - Add service layer type compatibility
+   - Add validation support
+   - Add display metadata support
 
-2. **Type Generation**
-   - Update TypeMapper for JSON types
-   - Generate interfaces from schemas
-   - Add metadata generation
-   - Preserve key paths
+2. **Generator Updates**
+   - Add JSON schema extraction
+   - Add JsonSetting class generation
+   - Update interface generation
+   - Add metadata extraction
+   - Add default value generation
+   - Add service metadata generation
+   - Add validation rule generation
+   - Add display metadata generation
 
 3. **Testing**
    - Add unit tests for schema extraction
-   - Add tests for type generation
-   - Validate generated TypeScript
+   - Add unit tests for JsonSetting generation
+   - Test JSON serialization/deserialization
+   - Validate metadata generation
    - Test with complex nested objects
 
-4. **Documentation**
-   - Update README with new features
-   - Document schema format
-   - Add examples for common patterns
-   - Document error handling
+## Benefits
+1. Automated JSON handling via JsonSetting
+2. Type-safe configuration via TypeScript interfaces
+3. Full JSON schema support
+4. Proper metadata preservation
+5. Consistent error handling
+6. Default value support
+7. Schema validation
+8. Service layer integration
+
+## Migration Plan
+1. Update generator to use new pattern
+2. Generate new TypeScript files
+3. Update existing code to use new pattern
+4. Add tests for new functionality
 
 ## Success Criteria
-1. Generated types include full JSON schema metadata
-2. Key paths are preserved from C# attributes
-3. Type-safe accessors are generated for JSON fields
-4. XML comments are parsed correctly
-5. Generated code compiles without errors
-6. Unit tests pass
-7. Documentation is complete
+1. All JSON fields use JsonSetting
+2. All setting keys match C# exactly
+3. All metadata is preserved
+4. JSON handling is automated
+5. Type safety is maintained
+6. JSON schemas are generated correctly
+7. Generated code compiles without errors
+8. Unit tests pass
+9. Service layer integration is successful
 
 ## Future Enhancements
-1. Support for JSON Schema validation
-2. Custom type mappings
-3. Schema versioning
-4. Migration helpers
-5. Schema documentation generation
+1. Custom type mappings
+2. Schema versioning
+3. Migration helpers
+4. Schema documentation generation
+5. Runtime schema validation
+6. Custom validation rules
