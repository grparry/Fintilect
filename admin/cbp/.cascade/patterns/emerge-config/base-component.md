# Emerge Config Base Component Pattern

## Pattern Overview
A base component pattern for configuration sections that supports both generated and custom implementations while maintaining type safety and validation.

## Core Principles
1. Single source of truth for configuration metadata
2. Type-safe access to configuration values
3. Consistent validation and error handling
4. Extensible layout system
5. Clear separation between generated and custom code

## Implementation

### Base Component Structure
```typescript
// src/components/emerge-config/base/EmergeConfigSection.tsx
export abstract class EmergeConfigSection<T = any> extends React.Component<ConfigSectionProps<T>> {
    static metadata: ConfigMetadata;
    
    // Core functionality
    protected abstract getDefaultValue(): T;
    protected abstract getValidationRules(): ValidationRules;
    
    // Base implementation
    getValue(): T;
    setValue(value: T): void;
    validate(): ValidationResult;
    getLayout(): LayoutDefinition;
}
```

### Metadata Types
```typescript
// src/components/emerge-config/base/types/metadata.ts
export interface ConfigMetadata {
    key: string;
    label: string;
    description?: string;
    category?: string;
    dependencies?: string[];
    schema?: JsonSchema;
    validation?: ValidationRules;
    layout?: LayoutDefinition;
}
```

### Layout System
```typescript
// src/components/emerge-config/base/types/layout.ts
export interface LayoutDefinition {
    type: 'form' | 'tabs' | 'grid' | 'custom';
    component?: string;
    sections?: LayoutSection[];
    props?: Record<string, any>;
}
```

## Usage Patterns

### 1. Generated Component
```typescript
// Generated by legacy-analyzer
export class AccountCategoriesSection extends EmergeConfigSection<AccountConfig> {
    static metadata: ConfigMetadata = {
        key: 'Account.Categories',
        label: 'Account Categories',
        category: 'Account Management'
    };

    protected getDefaultValue(): AccountConfig {
        return { categories: [] };
    }

    protected getValidationRules(): ValidationRules {
        return {
            'categories': { required: true }
        };
    }
}
```

### 2. Custom Override
```typescript
// Custom implementation
@ConfigSection({
    extends: AccountCategoriesSection
})
export class CustomAccountCategories extends AccountCategoriesSection {
    protected override getLayout(): LayoutDefinition {
        return {
            type: 'custom',
            component: 'CategoryEditor'
        };
    }
}
```

## Dependencies

### Required
- React
- TypeScript
- Settings Service Layer
- JSON Schema Validation

### Optional
- Custom Form Components
- Layout Engine
- Validation Extensions

## Pattern Rules

### 1. Component Rules
- Must extend EmergeConfigSection
- Must implement required abstract methods
- Must provide static metadata
- Must not modify base functionality

### 2. Generation Rules
- Generated code must be isolated
- Must preserve type safety
- Must include all metadata
- Must support overrides

### 3. Override Rules
- Must use @ConfigSection decorator
- Must not break base contract
- Must document customizations
- Must maintain type safety

## Testing Requirements

### Base Component
```typescript
describe('EmergeConfigSection', () => {
    it('should provide type-safe value access', () => {
        // Test implementation
    });

    it('should validate according to rules', () => {
        // Test implementation
    });

    it('should render correct layout', () => {
        // Test implementation
    });
});
```

### Generated Code
```typescript
describe('Generated Section', () => {
    it('should match snapshot', () => {
        // Test implementation
    });

    it('should preserve types', () => {
        // Test implementation
    });
});
```

## Anti-patterns

### 1. Avoid Direct Service Access
❌ Don't:
```typescript
class BadSection extends EmergeConfigSection {
    private service = new SettingsService();  // Direct instantiation
}
```

✅ Do:
```typescript
class GoodSection extends EmergeConfigSection {
    @inject(SettingsService)
    private service: ISettingsService;  // Dependency injection
}
```

### 2. Avoid Type Casting
❌ Don't:
```typescript
getValue() {
    return this.value as any;  // Type casting
}
```

✅ Do:
```typescript
getValue(): T {
    return this.value;  // Type-safe
}
```

## Migration Strategy

### 1. For Existing Components
1. Create base implementation
2. Generate new components
3. Create overrides as needed
4. Migrate gradually

### 2. For New Components
1. Define C# model
2. Generate component
3. Add custom logic if needed
4. Register in system

## Metrics

### Track
1. Override usage
2. Validation errors
3. Custom layouts
4. Performance metrics

### Monitor
1. Type safety violations
2. Pattern compliance
3. Test coverage
4. Documentation status
